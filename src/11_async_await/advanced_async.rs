//! # Advanced Async Programming - р╣Ар╕Чр╕Др╕Щр╕┤р╕Др╕Вр╕▒р╣Йр╕Щр╣Ар╕Чр╕Юр╣Бр╕лр╣Ир╕Зр╕нр╕Щр╕▓р╕Др╕Х! ЁЯзЩтАНтЩВя╕ПтЪб
//!
//! р╣Др╕Яр╕ер╣Мр╕Щр╕╡р╣Йр╕Ыр╕гр╕░р╕Бр╕нр╕Ър╕Фр╣Йр╕зр╕вр╣Ар╕Чр╕Др╕Щр╕┤р╕Др╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕Зр╕Чр╕╡р╣Ир╕Ир╕░р╕Чр╕│р╣Гр╕лр╣Йр╕Др╕╕р╕Ур╣Ар╕Ыр╣Зр╕Щр╕Щр╕┤р╕Щр╕Ир╕▓ async! ЁЯе╖тЬи
//!
//! ## р╕кр╕┤р╣Ир╕Зр╕Чр╕╡р╣Ир╕Ир╕░р╣Др╕Фр╣Йр╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Й: ЁЯОп
//! - ЁЯФо Custom Future Implementation - р╕кр╕гр╣Йр╕▓р╕З Future р╕Вр╕нр╕Зр╕Хр╕▒р╕зр╣Ар╕нр╕Зр╣Бр╕Ър╕Ъ DIY! ЁЯФз
//! - ЁЯУЛ Async Task Scheduler - р╕Хр╕▒р╕зр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Зр╕▓р╕Щр╣Бр╕Ър╕Ър╣Ар╕Чр╕Ю! (р╕Ьр╕╣р╣Йр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕з!)
//! - ЁЯУб Async Channels - р╕Кр╣Ир╕нр╕Зр╕Чр╕▓р╕Зр╕кр╕╖р╣Ир╕нр╕кр╕▓р╕гр╣Бр╕лр╣Ир╕Зр╕нр╕Щр╕▓р╕Др╕Х! (р╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣Мр╣Бр╕Ър╕Ъ async!)
//! - ЁЯМК Async Streams - р╕Бр╕гр╕░р╣Бр╕кр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕бр╣Ир╕гр╕╣р╣Йр╕Ир╕Ъ! (р╣Бр╕бр╣Ир╕Щр╣Йр╕│р╕Вр╣Йр╕нр╕бр╕╣р╕е!)
//! - ЁЯСе Worker Pools - р╕Чр╕╡р╕бр╕Зр╕▓р╕Щр╣Бр╕Ър╕Ъ async! (р╕Бр╕нр╕Зр╕Чр╕▒р╕Юр╕Щр╕┤р╕Щр╕Ир╕▓!)
//! - ЁЯФД Retry Mechanisms - р╕гр╕░р╕Ър╕Ър╕ер╕нр╕Зр╣Гр╕лр╕бр╣Ир╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤! (р╣Др╕бр╣Ир╕вр╕нр╕бр╣Бр╕Юр╣Й!)
//!
//! ЁЯОн р╣Ар╕Хр╕гр╕╡р╕вр╕бр╕Хр╕▒р╕зр╣Гр╕лр╣Йр╕Юр╕гр╣Йр╕нр╕б! р╣Ар╕гр╕▓р╕Ир╕░р╣Др╕Ыр╕Ьр╕Ир╕Нр╕ар╕▒р╕вр╣Гр╕Щр╣Вр╕ер╕Бр╕Вр╕нр╕З async р╕Вр╕▒р╣Йр╕Щр╣Ар╕Чр╕Юр╕Бр╕▒р╕Щ! ЁЯЪАтЬи

use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use std::time::{Duration, Instant};
use std::thread;

/// Custom Future Implementation - р╕кр╕гр╣Йр╕▓р╕З Future р╕Чр╕╡р╣Ир╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓р╣Бр╕Ър╕Ъ DIY! тП░ЁЯФз
/// р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Хр╕▒р╣Йр╕Зр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╣Бр╕Ър╕Ъ async! (р╣Бр╕Хр╣Ир╣Др╕бр╣Ир╕Ър╕ер╣Зр╕нр╕Бр╣Гр╕Др╕гр╣Ар╕ер╕в!) ЁЯШ┤ЁЯТд
struct DelayFuture {
    when: Instant,      // р╣Ар╕зр╕ер╕▓р╕Чр╕╡р╣Ир╕Ир╕░р╕Хр╕╖р╣Ир╕Щ - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Б! тП░
    waker: Option<Waker>, // р╕Хр╕▒р╕зр╕Ыр╕ер╕╕р╕Б - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Бр╕бр╣Ир╕Чр╕╡р╣Ир╕бр╕▓р╕Ыр╕ер╕╕р╕Бр╕Хр╕нр╕Щр╣Ар╕Кр╣Йр╕▓! ЁЯСйтАНЁЯСзтАНЁЯСж
}

impl DelayFuture {
    /// р╕кр╕гр╣Йр╕▓р╕З `DelayFuture` р╣Гр╕лр╕бр╣И - р╕Хр╕▒р╣Йр╕Зр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╣Бр╕Ър╕Ъ async! тП░тЬи
    fn new(duration: Duration) -> Self {
        println!("тП░ЁЯФз DelayFuture::new: р╕Хр╕▒р╣Йр╕Зр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╣Др╕зр╣Й {duration:?} (р╣Др╕бр╣Ир╕Ър╕ер╣Зр╕нр╕Бр╣Гр╕Др╕гр╕Щр╕░!)");
        Self {
            when: Instant::now() + duration, // р╕Др╕│р╕Щр╕зр╕Ур╣Ар╕зр╕ер╕▓р╕Чр╕╡р╣Ир╕Ир╕░р╕Хр╕╖р╣Ир╕Щ! ЁЯзо
            waker: None, // р╕вр╕▒р╕Зр╣Др╕бр╣Ир╕бр╕╡р╣Гр╕Др╕гр╕бр╕▓р╕Ыр╕ер╕╕р╕Б! ЁЯШ┤
        }
    }
}

impl Future for DelayFuture {
    type Output = ();
    
    /// р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕Цр╕╢р╕Зр╣Ар╕зр╕ер╕▓р╣Бр╕ер╣Йр╕зр╕лр╕гр╕╖р╕нр╕вр╕▒р╕З - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Фр╕╣р╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕зр╣Ир╕▓р╕Хр╕╖р╣Ир╕Щр╕лр╕гр╕╖р╕нр╕вр╕▒р╕З! ЁЯСАтП░
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if Instant::now() >= self.when {
            println!("тП░тЬЕ DelayFuture: р╕Хр╕╖р╣Ир╕Щр╣Бр╕ер╣Йр╕з! р╣Ар╕зр╕ер╕▓р╕Ьр╣Ир╕▓р╕Щр╣Др╕Ыр╕Др╕гр╕Ър╣Бр╕ер╣Йр╕з! (р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╕Фр╕▒р╕З!)");
            Poll::Ready(()) // р╕Хр╕╖р╣Ир╕Щр╣Бр╕ер╣Йр╕з! р╕Юр╕гр╣Йр╕нр╕бр╕Чр╕│р╕Зр╕▓р╕Щр╕Хр╣Ир╕н! ЁЯМЕ
        } else {
            // р╣Ар╕Бр╣Зр╕Ъ waker р╣Др╕зр╣Йр╕Ыр╕ер╕╕р╕Бр╕Чр╕╡р╕лр╕ер╕▒р╕З - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Ър╕нр╕Бр╣Бр╕бр╣Ир╕зр╣Ир╕▓р╣Гр╕лр╣Йр╕бр╕▓р╕Ыр╕ер╕╕р╕Бр╕Хр╕нр╕Щр╣Др╕лр╕Щ! ЁЯУЮ
            self.waker = Some(cx.waker().clone());
            println!("ЁЯШ┤ЁЯТд DelayFuture: р╕вр╕▒р╕Зр╣Др╕бр╣Ир╕Цр╕╢р╕Зр╣Ар╕зр╕ер╕▓... р╕Щр╕нр╕Щр╕Хр╣Ир╕н... ZZZ (р╣Др╕бр╣Ир╕Ър╕ер╣Зр╕нр╕Бр╣Гр╕Др╕гр╕Щр╕░!)");
            
            // р╣Гр╕Щр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕З р╕Др╕зр╕гр╣Гр╕Кр╣Й timer р╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б ЁЯОп
            // р╕Чр╕╡р╣Ир╕Щр╕╡р╣Ир╣Ар╕гр╕▓р╕Ир╕░р╣Гр╕Кр╣Й thread::spawn р╣Ар╕Юр╕╖р╣Ир╕нр╕Ир╕│р╕ер╕нр╕З (р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Ьр╕╡р╕Кр╣Ир╕зр╕вр╕Хр╕▒р╣Йр╕Зр╕Ыр╕ер╕╕р╕Б!) ЁЯС╗тП░
            let waker = cx.waker().clone();
            let when = self.when;
            thread::spawn(move || {
                let now = Instant::now();
                if when > now {
                    thread::sleep(when - now); // р╕Зр╕╡р╕Ър╕Ир╕гр╕┤р╕Зр╣Ж р╣Гр╕Щр╣Ар╕Шр╕гр╕Фр╣Бр╕вр╕Б! ЁЯШ┤
                }
                waker.wake(); // р╕Ыр╕ер╕╕р╕Бр╣Ар╕Ир╣Йр╕▓р╕Вр╕нр╕З! "р╕Хр╕╖р╣Ир╕Щр╣Др╕Фр╣Йр╣Бр╕ер╣Йр╕з!" ЁЯУв
            });
            
            Poll::Pending // р╕вр╕▒р╕Зр╣Др╕бр╣Ир╕Юр╕гр╣Йр╕нр╕б р╕гр╕нр╕Бр╣Ир╕нр╕Щ! тП│
        }
    }
}

/// Async Task Scheduler - р╕Хр╕▒р╕зр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Зр╕▓р╕Щр╣Бр╕Ър╕Ър╣Ар╕Чр╕Ю! ЁЯУЛтЪб
/// р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕бр╕╡р╕Ьр╕╣р╣Йр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕зр╕Чр╕╡р╣Ир╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Зр╕▓р╕Щр╣Гр╕лр╣Й! (р╣Ар╕ер╕Вр╕▓р╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕з!) ЁЯСйтАНЁЯТ╝тЬи
struct TaskScheduler {
    tasks: Vec<Pin<Box<dyn Future<Output = ()> + Send>>>, // р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕Зр╕▓р╕Щ - р╣Ар╕лр╕бр╕╖р╕нр╕Щ to-do list! ЁЯУЭ
    wakers: Vec<Waker>, // р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕Хр╕▒р╕зр╕Ыр╕ер╕╕р╕Б - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╕лр╕ер╕▓р╕вр╣Ар╕гр╕╖р╕нр╕Щ! тП░
}

impl TaskScheduler {
    /// р╕кр╕гр╣Йр╕▓р╕З `TaskScheduler` р╣Гр╕лр╕бр╣И - р╣Ар╕Ыр╕┤р╕Фр╕нр╕нр╕Яр╕Яр╕┤р╕ир╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Зр╕▓р╕Щ! ЁЯПвтЬи
    fn new() -> Self {
        println!("ЁЯПвЁЯУЛ TaskScheduler: р╣Ар╕Ыр╕┤р╕Фр╕нр╕нр╕Яр╕Яр╕┤р╕ир╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Зр╕▓р╕Щр╣Бр╕ер╣Йр╕з! р╕Юр╕гр╣Йр╕нр╕бр╕гр╕▒р╕Ър╕Зр╕▓р╕Щ! (р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Ыр╕┤р╕Фр╕Ър╕гр╕┤р╕йр╕▒р╕Ч!)");
        Self {
            tasks: Vec::new(), // р╣Вр╕Хр╣Кр╕░р╕Чр╕│р╕Зр╕▓р╕Щр╕зр╣Ир╕▓р╕Зр╣Ар╕Ыр╕ер╣Ир╕▓ р╕Юр╕гр╣Йр╕нр╕бр╕гр╕▒р╕Ър╕Зр╕▓р╕Щ! ЁЯУЭ
            wakers: Vec::new(), // р╕вр╕▒р╕Зр╣Др╕бр╣Ир╕бр╕╡р╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Б! тП░
        }
    }
    
    /// р╣Ар╕Юр╕┤р╣Ир╕бр╕Зр╕▓р╕Щр╣Гр╕лр╕бр╣И - р╕гр╕▒р╕Ър╕Зр╕▓р╕Щр╣Ар╕Вр╣Йр╕▓р╕гр╕░р╕Ър╕Ъ! ЁЯУе
    fn spawn<F>(&mut self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        println!("ЁЯУеЁЯТ╝ TaskScheduler: р╕гр╕▒р╕Ър╕Зр╕▓р╕Щр╣Гр╕лр╕бр╣Ир╣Ар╕Вр╣Йр╕▓р╕гр╕░р╕Ър╕Ъ! р╕Зр╕▓р╕Щр╕Чр╕╡р╣И {} (р╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕Вр╣Йр╕▓р╕Др╕┤р╕з!)", self.tasks.len() + 1);
        self.tasks.push(Box::pin(future)); // р╣Ар╕Юр╕┤р╣Ир╕бр╕Зр╕▓р╕Щр╣Ар╕Вр╣Йр╕▓р╕Др╕┤р╕з! ЁЯУЛ
    }
    
    /// р╕гр╕▒р╕Щр╕Зр╕▓р╕Щр╕Ир╕Щр╣Ар╕кр╕гр╣Зр╕Ир╕лр╕бр╕Ф - р╕Чр╕│р╕Зр╕▓р╕Щр╕Ир╕Щр╣Ар╕кр╕гр╣Зр╕И! ЁЯТк
    fn run_until_complete(&mut self) {
        println!("ЁЯЪАЁЯУЛ TaskScheduler: р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕│р╕Зр╕▓р╕Щ! р╕бр╕╡р╕Зр╕▓р╕Щр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф {} р╕Зр╕▓р╕Щ (р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Ыр╕┤р╕Фр╣Вр╕гр╕Зр╕Зр╕▓р╕Щ!)", self.tasks.len());
        
        while !self.tasks.is_empty() {
            let mut completed = Vec::new();
            
            for (i, task) in self.tasks.iter_mut().enumerate() {
                let waker = futures::task::noop_waker(); // р╕Ьр╕╣р╣Йр╕Ыр╕ер╕╕р╕Бр╕Ир╕│р╕ер╕нр╕З (р╣Др╕бр╣Ир╕Чр╕│р╕нр╕░р╣Др╕гр╕Ир╕гр╕┤р╕Зр╣Ж!) ЁЯШ┤
                let mut context = Context::from_waker(&waker);
                
                match task.as_mut().poll(&mut context) {
                    Poll::Ready(()) => {
                        println!("тЬЕЁЯОЙ TaskScheduler: р╕Зр╕▓р╕Щр╕Чр╕╡р╣И {} р╣Ар╕кр╕гр╣Зр╕Ир╣Бр╕ер╣Йр╕з! (р╕ер╕Ър╕нр╕нр╕Бр╕Ир╕▓р╕Бр╕гр╕▓р╕вр╕Бр╕▓р╕г!)", i + 1);
                        completed.push(i);
                    },
                    Poll::Pending => {
                        println!("тП│тПня╕П TaskScheduler: р╕Зр╕▓р╕Щр╕Чр╕╡р╣И {} р╕вр╕▒р╕Зр╣Др╕бр╣Ир╣Ар╕кр╕гр╣Зр╕И р╕гр╕нр╕Хр╣Ир╕н... (р╕Вр╣Йр╕▓р╕бр╣Др╕Ыр╕Зр╕▓р╕Щр╕Хр╣Ир╕нр╣Др╕Ы!)", i + 1);
                    },
                }
            }
            
            // р╕ер╕Ър╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╣Ар╕кр╕гр╣Зр╕Ир╣Бр╕ер╣Йр╕з (р╣Ар╕гр╕╡р╕вр╕Зр╕Ир╕▓р╕Бр╕лр╕ер╕▒р╕Зр╣Др╕Ыр╕лр╕Щр╣Йр╕▓р╣Ар╕Юр╕╖р╣Ир╕нр╕гр╕▒р╕Бр╕йр╕▓ index) ЁЯЧСя╕П
            for &i in completed.iter().rev() {
                let _ = self.tasks.remove(i); // р╣Ар╕нр╕▓р╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╣Ар╕кр╕гр╣Зр╕Ир╕нр╕нр╕Б! ЁЯЧСя╕П
            }
            
            if !self.tasks.is_empty() {
                thread::sleep(Duration::from_millis(10)); // р╕Юр╕▒р╕Бр╣Ар╕ер╣Зр╕Бр╕Щр╣Йр╕нр╕в (р╕Юр╕▒р╕Бр╕Хр╕▓р╕лр╕Щр╣Ир╕нр╕в!) ЁЯСБя╕П
            }
        }
        
        println!("ЁЯОЙЁЯПЖ TaskScheduler: р╕Зр╕▓р╕Щр╣Ар╕кр╕гр╣Зр╕Ир╕лр╕бр╕Фр╣Бр╕ер╣Йр╕з! р╕Ыр╕┤р╕Фр╕нр╕нр╕Яр╕Яр╕┤р╕и! (р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Ыр╕┤р╕Фр╣Вр╕гр╕Зр╕Зр╕▓р╕Щ!)");
    }
}

/// Async Channel Implementation - р╕Кр╣Ир╕нр╕Зр╕Чр╕▓р╕Зр╕кр╕╖р╣Ир╕нр╕кр╕▓р╕гр╣Бр╕лр╣Ир╕Зр╕нр╕Щр╕▓р╕Др╕Х! ЁЯУбтЪб
/// р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕бр╕╡р╕Чр╣Ир╕нр╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕Ър╕Ъ async!
struct AsyncChannel<T> {
    buffer: Arc<Mutex<Vec<T>>>,           // р╕Чр╕╡р╣Ир╣Ар╕Бр╣Зр╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУо
    capacity: usize,                      // р╕Др╕зр╕▓р╕бр╕Ир╕╕ - р╕Вр╕Щр╕▓р╕Фр╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУП
    senders: Arc<Mutex<Vec<Waker>>>,      // р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕Ьр╕╣р╣Йр╕кр╣Ир╕З - р╕Др╕┤р╕зр╕Др╕Щр╕кр╣Ир╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУд
    receivers: Arc<Mutex<Vec<Waker>>>,    // р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕Ьр╕╣р╣Йр╕гр╕▒р╕Ъ - р╕Др╕┤р╕зр╕Др╕Щр╕гр╕▒р╕Ър╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУе
}

/// р╕Хр╕▒р╕зр╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕Ър╕╕р╕гр╕╕р╕йр╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣М! ЁЯУоЁЯСитАНЁЯТ╝
struct AsyncSender<T> {
    channel: Arc<AsyncChannel<T>>,
}

/// р╕Хр╕▒р╕зр╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕Др╕Щр╕гр╕▒р╕Ър╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУмЁЯСйтАНЁЯТ╝
struct AsyncReceiver<T> {
    channel: Arc<AsyncChannel<T>>,
}

/// Future р╕кр╕│р╕лр╕гр╕▒р╕Ър╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕Бр╕гр╕░р╕Ър╕зр╕Щр╕Бр╕▓р╕гр╕кр╣Ир╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУотЪб
struct SendFuture<T> {
    channel: Arc<AsyncChannel<T>>,
    item: Option<T>,
}

/// Future р╕кр╕│р╕лр╕гр╕▒р╕Ър╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕Бр╕гр╕░р╕Ър╕зр╕Щр╕Бр╕▓р╕гр╕гр╕▒р╕Ър╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУмтЪб
struct ReceiveFuture<T> {
    channel: Arc<AsyncChannel<T>>,
}

impl<T> AsyncChannel<T> {
    /// р╕кр╕гр╣Йр╕▓р╕З channel р╣Гр╕лр╕бр╣И - р╣Ар╕Ыр╕┤р╕Фр╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣Мр╣Гр╕лр╕бр╣И! ЁЯПдтЬи
    fn new(capacity: usize) -> (AsyncSender<T>, AsyncReceiver<T>) {
        println!("ЁЯПд AsyncChannel: р╣Ар╕Ыр╕┤р╕Фр╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣Мр╣Гр╕лр╕бр╣И! р╕Др╕зр╕▓р╕бр╕Ир╕╕ {capacity} р╕Кр╕┤р╣Йр╕Щ");
        
        let channel = Arc::new(Self {
            buffer: Arc::new(Mutex::new(Vec::new())),
            capacity,
            senders: Arc::new(Mutex::new(Vec::new())),
            receivers: Arc::new(Mutex::new(Vec::new())),
        });
        
        let sender = AsyncSender {
            channel: channel.clone(),
        };
        
        let receiver = AsyncReceiver {
            channel,
        };
        
        (sender, receiver)
    }
}

impl<T> AsyncSender<T> {
    /// р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕кр╣Ир╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУо
    fn send(&self, item: T) -> SendFuture<T> {
        println!("ЁЯУо AsyncSender: р╣Ар╕Хр╕гр╕╡р╕вр╕бр╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е...");
        SendFuture {
            channel: self.channel.clone(),
            item: Some(item),
        }
    }
}

impl<T> AsyncReceiver<T> {
    /// р╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕гр╕▒р╕Ър╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУм
    fn receive(&self) -> ReceiveFuture<T> {
        println!("ЁЯУм AsyncReceiver: р╣Ар╕Хр╕гр╕╡р╕вр╕бр╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е...");
        ReceiveFuture {
            channel: self.channel.clone(),
        }
    }
}

impl<T: Unpin> Future for SendFuture<T> {
    type Output = Result<(), T>;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.get_mut();
        let mut buffer = this.channel.buffer.lock().unwrap();
        
        if buffer.len() < this.channel.capacity {
            if let Some(item) = this.item.take() {
                buffer.push(item);
                println!("тЬЕ SendFuture: р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╣Ар╕гр╣Зр╕И! р╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕бр╕╡ {} р╕Кр╕┤р╣Йр╕Щ", buffer.len());
                
                // р╕Ыр╕ер╕╕р╕Бр╕Ьр╕╣р╣Йр╕гр╕▒р╕Ър╕Чр╕╡р╣Ир╕гр╕нр╕нр╕вр╕╣р╣И - р╣Бр╕Ир╣Йр╕Зр╕зр╣Ир╕▓р╕бр╕╡р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕бр╕▓р╣Бр╕ер╣Йр╕з! ЁЯУв
                let mut receivers = this.channel.receivers.lock().unwrap();
                for waker in receivers.drain(..) {
                    waker.wake();
                }
                
                Poll::Ready(Ok(()))
            } else {
                Poll::Ready(Err(this.item.take().unwrap_or_else(|| panic!("Item already taken"))))
            }
        } else {
            // р╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╣Ар╕Хр╣Зр╕б р╕гр╕нр╣Гр╕лр╣Йр╕бр╕╡р╕Чр╕╡р╣Ир╕зр╣Ир╕▓р╕З! ЁЯУотП│
            println!("ЁЯУотП│ SendFuture: р╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╣Ар╕Хр╣Зр╕б! р╕гр╕нр╣Гр╕лр╣Йр╕бр╕╡р╕Чр╕╡р╣Ир╕зр╣Ир╕▓р╕З...");
            let mut senders = this.channel.senders.lock().unwrap();
            senders.push(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl<T> Future for ReceiveFuture<T> {
    type Output = Option<T>;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let mut buffer = self.channel.buffer.lock().unwrap();
        
        if buffer.is_empty() {
            // р╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕зр╣Ир╕▓р╕З р╕гр╕нр╣Гр╕лр╣Йр╕бр╕╡р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕бр╕▓! ЁЯУмтП│
            println!("ЁЯУмтП│ ReceiveFuture: р╕Бр╕ер╣Ир╕нр╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕зр╣Ир╕▓р╕З! р╕гр╕нр╕Ир╕Фр╕лр╕бр╕▓р╕вр╣Гр╕лр╕бр╣И...");
            let mut receivers = self.channel.receivers.lock().unwrap();
            receivers.push(cx.waker().clone());
            Poll::Pending
        } else {
            let item = buffer.remove(0);
            println!("тЬЕ ReceiveFuture: р╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╣Ар╕гр╣Зр╕И! р╣Ар╕лр╕ер╕╖р╕нр╣Гр╕Щр╕Бр╕ер╣Ир╕нр╕З {} р╕Кр╕┤р╣Йр╕Щ", buffer.len());
            
            // р╕Ыр╕ер╕╕р╕Бр╕Ьр╕╣р╣Йр╕кр╣Ир╕Зр╕Чр╕╡р╣Ир╕гр╕нр╕нр╕вр╕╣р╣И - р╣Бр╕Ир╣Йр╕Зр╕зр╣Ир╕▓р╕бр╕╡р╕Чр╕╡р╣Ир╕зр╣Ир╕▓р╕Зр╣Бр╕ер╣Йр╕з! ЁЯУв
            let mut senders = self.channel.senders.lock().unwrap();
            for waker in senders.drain(..) {
                waker.wake();
            }
            
            Poll::Ready(Some(item))
        }
    }
}

/// р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Advanced Async - р╣Вр╕Кр╕зр╣Мр╣Ар╕Чр╕Др╕Щр╕┤р╕Др╕Вр╕▒р╣Йр╕Щр╣Ар╕Чр╕Ю! ЁЯОнтЪб
pub async fn demonstrate_advanced_async() {
    println!("\nЁЯзЩтАНтЩВя╕П === Advanced Async Programming: р╣Ар╕Чр╕Др╕Щр╕┤р╕Др╕Вр╕▒р╣Йр╕Щр╣Ар╕Чр╕Ю! === ЁЯзЩтАНтЩВя╕П");
    println!("ЁЯОп р╣Ар╕Хр╕гр╕╡р╕вр╕бр╕Юр╕Ър╕Бр╕▒р╕Ър╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣М async р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З!\n");
    
    // р╕Чр╕Фр╕кр╕нр╕Ъ Custom DelayFuture
    println!("тП░ === р╕Чр╕Фр╕кр╕нр╕Ъ Custom DelayFuture === тП░");
    println!("ЁЯФо р╕кр╕гр╣Йр╕▓р╕З DelayFuture р╕Чр╕╡р╣Ир╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓ 100ms...");
    
    let delay = DelayFuture::new(Duration::from_millis(100));
    delay.await;
    
    println!("тЬи DelayFuture р╣Ар╕кр╕гр╣Зр╕Ир╕кр╕┤р╣Йр╕Щ!\n");
    
    // р╕Чр╕Фр╕кр╕нр╕Ъ TaskScheduler
    println!("ЁЯУЛ === р╕Чр╕Фр╕кр╕нр╕Ъ TaskScheduler === ЁЯУЛ");
    let mut scheduler = TaskScheduler::new();
    
    // р╣Ар╕Юр╕┤р╣Ир╕бр╕Зр╕▓р╕Щр╕лр╕ер╕▓р╕вр╣Ж р╕Зр╕▓р╕Щ
    scheduler.spawn(async {
        println!("ЁЯОп р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 1: р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕│р╕Зр╕▓р╕Щ...");
        DelayFuture::new(Duration::from_millis(50)).await;
        println!("тЬЕ р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 1: р╣Ар╕кр╕гр╣Зр╕Ир╣Бр╕ер╣Йр╕з!");
    });
    
    scheduler.spawn(async {
        println!("ЁЯОп р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 2: р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕│р╕Зр╕▓р╕Щ...");
        DelayFuture::new(Duration::from_millis(30)).await;
        println!("тЬЕ р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 2: р╣Ар╕кр╕гр╣Зр╕Ир╣Бр╕ер╣Йр╕з!");
    });
    
    scheduler.spawn(async {
        println!("ЁЯОп р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 3: р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕│р╕Зр╕▓р╕Щ...");
        DelayFuture::new(Duration::from_millis(20)).await;
        println!("тЬЕ р╕Зр╕▓р╕Щр╕Чр╕╡р╣И 3: р╣Ар╕кр╕гр╣Зр╕Ир╣Бр╕ер╣Йр╕з!");
    });
    
    // р╕гр╕▒р╕Щр╕Зр╕▓р╕Щр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф
    scheduler.run_until_complete();
    
    println!("\nЁЯУб === р╕Чр╕Фр╕кр╕нр╕Ъ Async Channel === ЁЯУб");
    let (sender, receiver) = AsyncChannel::new(2);
    
    // р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е
    println!("ЁЯУд р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ьр╣Ир╕▓р╕Щ channel...");
    let send_result = sender.send("Hello Async World! ЁЯМН".to_string()).await;
    match send_result {
        Ok(()) => println!("тЬЕ р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╣Ар╕гр╣Зр╕И!"),
        Err(data) => println!("тЭМ р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕бр╣Ир╕кр╕│р╣Ар╕гр╣Зр╕И: {data}"),
    }
    
    // р╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е
    println!("ЁЯУе р╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б channel...");
    if let Some(data) = receiver.receive().await {
        println!("тЬЕ р╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╣Ар╕гр╣Зр╕И: {data}");
    } else {
        println!("тЭМ р╣Др╕бр╣Ир╕бр╕╡р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕Щр╕Кр╣Ир╕нр╕Зр╕Чр╕▓р╕З");
    }
    
    println!("\nЁЯОЙ === Advanced Async Programming р╣Ар╕кр╕гр╣Зр╕Ир╕кр╕┤р╣Йр╕Щ! === ЁЯОЙ");
    println!("ЁЯТб р╕Др╕╕р╕Ур╣Др╕Фр╣Йр╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Й:");
    println!("   ЁЯФз р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕З Custom Future");
    println!("   ЁЯУЛ р╕Бр╕▓р╕гр╣Гр╕Кр╣Й Task Scheduler");
    println!("   ЁЯУб р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕З Async Channel");
    println!("   тЪб р╣Ар╕Чр╕Др╕Щр╕┤р╕Д async р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З");
    println!("ЁЯЪА р╕Хр╕нр╕Щр╕Щр╕╡р╣Йр╕Др╕╕р╕Ур╣Ар╕Ыр╣Зр╕Щр╕Щр╕┤р╕Щр╕Ир╕▓ async р╣Бр╕ер╣Йр╕з! ЁЯе╖тЬи");
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::timeout;
    
    /// р╕Чр╕Фр╕кр╕нр╕Ъ DelayFuture - р╕Чр╕Фр╕кр╕нр╕Ър╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Б async! тП░ЁЯзк
    #[tokio::test]
    async fn test_delay_future() {
        println!("ЁЯзктП░ р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕Фр╕кр╕нр╕Ъ DelayFuture! (р╕Чр╕Фр╕кр╕нр╕Ър╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Б!)");
        let start = Instant::now();
        DelayFuture::new(Duration::from_millis(50)).await;
        let elapsed = start.elapsed();
        
        println!("тП▒я╕П р╣Ар╕зр╕ер╕▓р╕Чр╕╡р╣Ир╣Гр╕Кр╣Й: {elapsed:?} (р╕Др╕зр╕гр╣Гр╕Бр╕ер╣Йр╣Ар╕Др╕╡р╕вр╕З 50ms!)");
        assert!(elapsed >= Duration::from_millis(45)); // р╕нр╕Щр╕╕р╕Нр╕▓р╕Хр╣Гр╕лр╣Йр╕Др╕ер╕▓р╕Фр╣Ар╕Др╕ер╕╖р╣Ир╕нр╕Щр╣Ар╕ер╣Зр╕Бр╕Щр╣Йр╕нр╕в ЁЯУП
        println!("тЬЕ DelayFuture р╕Чр╕│р╕Зр╕▓р╕Щр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З! (р╕Щр╕▓р╕мр╕┤р╕Бр╕▓р╕Ыр╕ер╕╕р╕Бр╣Бр╕бр╣Ир╕Щр╕вр╕│!) ЁЯОп");
    }
    
    /// р╕Чр╕Фр╕кр╕нр╕Ъ Async Channel - р╕Чр╕Фр╕кр╕нр╕Ър╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣М async! ЁЯУбЁЯзк
    #[tokio::test]
    async fn test_async_channel() {
        println!("ЁЯзкЁЯУб р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕Фр╕кр╕нр╕Ъ Async Channel! (р╕Чр╕Фр╕кр╕нр╕Ър╣Др╕Ыр╕гр╕йр╕Ур╕╡р╕вр╣М!)");
        let (sender, receiver) = AsyncChannel::new(1);
        
        // р╕Чр╕Фр╕кр╕нр╕Ър╕кр╣Ир╕Зр╣Бр╕ер╕░р╕гр╕▒р╕Ъ - р╕кр╣Ир╕Зр╕Ир╕Фр╕лр╕бр╕▓р╕вр╣Бр╕ер╕░р╕гр╕▒р╕Ър╕Ир╕Фр╕лр╕бр╕▓р╕в! ЁЯУоЁЯУм
        println!("ЁЯУо р╕Чр╕Фр╕кр╕нр╕Ър╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е 42...");
        let send_result = sender.send(42).await;
        assert!(send_result.is_ok());
        println!("тЬЕ р╕кр╣Ир╕Зр╕кр╕│р╣Ар╕гр╣Зр╕И! (р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕кр╣Ир╕Зр╣Бр╕ер╣Йр╕з!)");
        
        println!("ЁЯУм р╕Чр╕Фр╕кр╕нр╕Ър╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е...");
        let received = receiver.receive().await;
        assert_eq!(received, Some(42));
        println!("тЬЕ р╕гр╕▒р╕Ър╕кр╕│р╣Ар╕гр╣Зр╕И! р╣Др╕Фр╣Йр╕Вр╣Йр╕нр╕бр╕╣р╕е: {received:?} (р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕Цр╕╢р╕Зр╕бр╕╖р╕нр╣Бр╕ер╣Йр╕з!) ЁЯОЙ");
    }
    
    /// р╕Чр╕Фр╕кр╕нр╕Ъ Channel Timeout - р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▓р╕гр╕лр╕бр╕Фр╣Ар╕зр╕ер╕▓! тП░ЁЯзк
    #[tokio::test]
    async fn test_async_channel_timeout() {
        println!("ЁЯзктП░ р╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕Фр╕кр╕нр╕Ъ Channel Timeout! (р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▓р╕гр╕гр╕нр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕▓!)");
        let (_sender, receiver) = AsyncChannel::<i32>::new(1);
        
        // р╕Чр╕Фр╕кр╕нр╕Ъ timeout р╣Ар╕бр╕╖р╣Ир╕нр╣Др╕бр╣Ир╕бр╕╡р╕Вр╣Йр╕нр╕бр╕╣р╕е - р╕гр╕нр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕▓! ЁЯУнтП│
        println!("ЁЯУн р╕гр╕нр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕╡... (р╕Др╕зр╕г timeout!)");
        let result = timeout(Duration::from_millis(10), receiver.receive()).await;
        assert!(result.is_err()); // р╕Др╕зр╕г timeout ЁЯТе
        println!("тЬЕ Timeout р╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З! (р╣Др╕бр╣Ир╕гр╕нр╕Ир╕Фр╕лр╕бр╕▓р╕вр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕▓р╕Хр╕ер╕нр╕Фр╣Др╕Ы!) тП░тЬи");
    }
}