//! ЁЯФР Web Development Workshop: Hashing and Digital Signatures ЁЯФР
//!
//! ЁЯОп р╕вр╕┤р╕Щр╕Фр╕╡р╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╕кр╕╣р╣Ир╣Ар╕зр╕┤р╕гр╣Мр╕Др╕Кр╣Зр╕нр╕Ы "р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕ер╣Бр╕ер╕░р╕Бр╕▓р╕гр╣Бр╕ор╕К"!
//! ЁЯУЪ р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕зр╕┤р╕Шр╕╡р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕ер╕кр╕│р╕лр╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е
//! ЁЯЫбя╕П р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕Хр╕гр╕▓р╕Ыр╕гр╕░р╕Чр╕▒р╕Ър╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Ыр╕ер╕нр╕бр╣Бр╕Ыр╕ер╕Зр╣Др╕Фр╣Й!

use std::collections::HashMap;
use std::fmt;

/// ЁЯФН р╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Вр╕нр╕Зр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╣Бр╕ор╕К - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е
/// ЁЯОи р╣Бр╕Хр╣Ир╕ер╕░р╣Бр╕Ър╕Ър╕Ир╕░р╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Чр╕╡р╣Ир╣Бр╕Хр╕Бр╕Хр╣Ир╕▓р╕Зр╕Бр╕▒р╕Щ!
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HashAlgorithm {
    Md5,
    Sha1,
    Sha256,
    Sha512,
    Blake2b,
    Argon2,
}

/// ЁЯУЛ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Бр╕▓р╕гр╣Бр╕ор╕К - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Гр╕Ър╕гр╕▒р╕Ър╕гр╕нр╕Зр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е
/// ЁЯОп р╣Ар╕Бр╣Зр╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╣Бр╕ер╕░р╕зр╕┤р╕Шр╕╡р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct HashResult {
    pub algorithm: HashAlgorithm,
    pub hash: Vec<u8>,
    pub hex_string: String,
}

impl HashResult {
    fn new(algorithm: HashAlgorithm, hash: Vec<u8>) -> Self {
        let hex_string = hash.iter()
            .map(|b| format!("{b:02x}"))
            .collect::<String>();
        
        Self {
            algorithm,
            hash,
            hex_string,
        }
    }
    
    fn verify(&self, input: &[u8], hasher: &dyn Hasher) -> bool {
        let computed = hasher.hash(input);
        computed.hash == self.hash
    }
}

impl fmt::Display for HashResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}: {}", self.algorithm, self.hex_string)
    }
}

/// ЁЯФз Trait р╕кр╕│р╕лр╕гр╕▒р╕Ър╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕К - р╕Юр╕┤р╕бр╕Юр╣Мр╣Ар╕Вр╕╡р╕вр╕зр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щ
/// ЁЯОк р╕Чр╕╕р╕Бр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╕Хр╣Йр╕нр╕Зр╕бр╕╡р╕Др╕зр╕▓р╕бр╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щр╣Ар╕лр╕ер╣Ир╕▓р╕Щр╕╡р╣Й!
trait Hasher {
    fn hash(&self, input: &[u8]) -> HashResult;
    fn algorithm(&self) -> HashAlgorithm;
}

/// ЁЯФ┤ MD5 Hasher - р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕Кр╕гр╕╕р╣Ир╕Щр╣Ар╕Бр╣Ир╕▓ (р╣Гр╕Кр╣Йр╣Ар╕Юр╕╖р╣Ир╕нр╕Бр╕▓р╕гр╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╣Ар╕Чр╣Ир╕▓р╕Щр╕▒р╣Йр╕Щ)
/// тЪая╕П р╕лр╕бр╕▓р╕вр╣Ар╕лр╕Хр╕╕: р╣Др╕бр╣Ир╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕вр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕З!
struct Md5Hasher;

impl Hasher for Md5Hasher {
    fn hash(&self, input: &[u8]) -> HashResult {
        // Simplified MD5 simulation
        let mut hash = vec![0u8; 16];
        let mut state = 0x67452301u32;
        
        for (i, &byte) in input.iter().enumerate() {
            state = state.wrapping_add(u32::from(byte));
            state = state.rotate_left((i % 32) as u32);
            hash[i % 16] = (state ^ u32::from(byte)) as u8;
        }
        
        // Add some more mixing
        for i in 0..16 {
            hash[i] = hash[i].wrapping_add((state >> (i * 2)) as u8);
        }
        
        HashResult::new(HashAlgorithm::Md5, hash)
    }
    
    fn algorithm(&self) -> HashAlgorithm {
        HashAlgorithm::Md5
    }
}

/// ЁЯЯв SHA-256 Hasher - р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕Кр╕бр╕▓р╕Хр╕гр╕Рр╕▓р╕Щр╕Чр╕╡р╣Ир╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕в
/// ЁЯПЖ р╣Ар╕Ыр╣Зр╕Щр╕Чр╕╡р╣Ир╕Щр╕┤р╕вр╕бр╣Гр╕Кр╣Йр╣Гр╕Щр╕гр╕░р╕Ър╕Ъ Bitcoin р╣Бр╕ер╕░р╣Ар╕зр╣Зр╕Ър╣Др╕Лр╕Хр╣Мр╕Хр╣Ир╕▓р╕Зр╣Ж!
struct Sha256Hasher;

impl Hasher for Sha256Hasher {
    fn hash(&self, input: &[u8]) -> HashResult {
        // Simplified SHA-256 simulation
        let mut hash = vec![0u8; 32];
        let mut state = [
            0x6a09e667u32, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ];
        
        // Process input in chunks
        let mut processed = 0;
        for chunk in input.chunks(64) {
            for (i, &byte) in chunk.iter().enumerate() {
                let state_idx = i % 8;
                state[state_idx] = state[state_idx]
                    .wrapping_add(u32::from(byte))
                    .rotate_left(((i + processed) % 32) as u32);
            }
            processed += chunk.len();
        }
        
        // Convert state to bytes
        for (i, &word) in state.iter().enumerate() {
            let bytes = word.to_be_bytes();
            hash[i * 4..(i + 1) * 4].copy_from_slice(&bytes);
        }
        
        HashResult::new(HashAlgorithm::Sha256, hash)
    }
    
    fn algorithm(&self) -> HashAlgorithm {
        HashAlgorithm::Sha256
    }
}

/// ЁЯФ╡ SHA-512 Hasher - р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕Кр╕Др╕зр╕▓р╕бр╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕вр╕кр╕╣р╕З
/// ЁЯТк р╣Бр╕Вр╣Зр╕Зр╣Бр╕Бр╕гр╣Ир╕Зр╕Бр╕зр╣Ир╕▓ SHA-256 р╣Ар╕лр╕бр╕▓р╕░р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╕Др╕▒р╕Н!
struct Sha512Hasher;

impl Hasher for Sha512Hasher {
    fn hash(&self, input: &[u8]) -> HashResult {
        // Simplified SHA-512 simulation
        let mut hash = vec![0u8; 64];
        let mut state = [
            0x6a09e667f3bcc908u64, 0xbb67ae8584caa73b,
            0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
            0x510e527fade682d1, 0x9b05688c2b3e6c1f,
            0x1f83d9abfb41bd6b, 0x5be0cd19137e2179,
        ];
        
        // Process input
        let mut processed = 0;
        for chunk in input.chunks(128) {
            for (i, &byte) in chunk.iter().enumerate() {
                let state_idx = i % 8;
                state[state_idx] = state[state_idx]
                    .wrapping_add(u64::from(byte))
                    .rotate_left(((i + processed) % 64) as u32);
            }
            processed += chunk.len();
        }
        
        // Convert state to bytes
        for (i, &word) in state.iter().enumerate() {
            let bytes = word.to_be_bytes();
            hash[i * 8..(i + 1) * 8].copy_from_slice(&bytes);
        }
        
        HashResult::new(HashAlgorithm::Sha512, hash)
    }
    
    fn algorithm(&self) -> HashAlgorithm {
        HashAlgorithm::Sha512
    }
}

/// ЁЯЯг `BLAKE2b` Hasher - р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕Кр╕гр╕╕р╣Ир╕Щр╣Гр╕лр╕бр╣Ир╕Чр╕╡р╣Ир╣Ар╕гр╣Зр╕зр╣Бр╕ер╕░р╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕в
/// тЪб р╣Ар╕гр╣Зр╕зр╕Бр╕зр╣Ир╕▓ SHA-3 р╣Бр╕Хр╣Ир╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕вр╣Ар╕Чр╣Ир╕▓р╕Бр╕▒р╕Щ!
struct Blake2bHasher;

impl Hasher for Blake2bHasher {
    fn hash(&self, input: &[u8]) -> HashResult {
        // Simplified BLAKE2b simulation
        let mut hash = vec![0u8; 64];
        let mut state = [
            0x6a09e667f2bdc948u64, 0xbb67ae8584caa73b,
            0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
            0x510e527fade682d1, 0x9b05688c2b3e6c1f,
            0x1f83d9abfb41bd6b, 0x5be0cd19137e2179,
        ];
        
        // BLAKE2b specific initialization
        state[0] ^= 0x01010040; // Parameter block
        
        // Process input
        for (i, &byte) in input.iter().enumerate() {
            let state_idx = i % 8;
            state[state_idx] = state[state_idx]
                .wrapping_add(u64::from(byte))
                .rotate_right(((i % 63) + 1) as u32); // Different rotation
        }
        
        // Final mixing
        for i in 0..8 {
            state[i] ^= state[(i + 4) % 8];
        }
        
        // Convert to bytes
        for (i, &word) in state.iter().enumerate() {
            let bytes = word.to_le_bytes(); // Little-endian for BLAKE2b
            hash[i * 8..(i + 1) * 8].copy_from_slice(&bytes);
        }
        
        HashResult::new(HashAlgorithm::Blake2b, hash)
    }
    
    fn algorithm(&self) -> HashAlgorithm {
        HashAlgorithm::Blake2b
    }
}

/// ЁЯФС р╕Бр╕▓р╕гр╣Бр╕ор╕Кр╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щр╕Юр╕гр╣Йр╕нр╕бр╣Ар╕Бр╕ер╕╖р╕н - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╣Ар╕Бр╣Зр╕Ър╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щр╣Гр╕Щр╕Хр╕╣р╣Йр╣Ар╕Лр╕Я
/// ЁЯзВ р╣Ар╕Бр╕ер╕╖р╕нр╕Кр╣Ир╕зр╕вр╕Ыр╣Йр╕нр╕Зр╕Бр╕▒р╕Щр╕Бр╕▓р╕гр╣Вр╕Ир╕бр╕Хр╕╡р╣Бр╕Ър╕Ъ Rainbow Table!
#[derive(Debug, Clone)]
pub struct PasswordHash {
    pub algorithm: HashAlgorithm,
    pub salt: Vec<u8>,
    pub hash: Vec<u8>,
    pub iterations: u32,
}

impl PasswordHash {
    const fn new(algorithm: HashAlgorithm, salt: Vec<u8>, hash: Vec<u8>, iterations: u32) -> Self {
        Self {
            algorithm,
            salt,
            hash,
            iterations,
        }
    }
    
    fn verify(&self, password: &str, hasher: &PasswordHasher) -> bool {
        let computed = hasher.hash_password(password, &self.salt, self.iterations);
        computed.hash == self.hash
    }
    
    fn to_string(&self) -> String {
        let salt_hex = self.salt.iter().map(|b| format!("{b:02x}")).collect::<String>();
        let hash_hex = self.hash.iter().map(|b| format!("{b:02x}")).collect::<String>();
        format!("{:?}:{}:{}:{}", self.algorithm, self.iterations, salt_hex, hash_hex)
    }
}

/// ЁЯФР р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╣Бр╕ор╕Кр╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щ - р╕Ьр╕╣р╣Йр╣Ар╕Кр╕╡р╣Ир╕вр╕зр╕Кр╕▓р╕Нр╕Фр╣Йр╕▓р╕Щр╕Бр╕▓р╕гр╕Ыр╕Бр╕Ыр╣Йр╕нр╕Зр╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щ
/// ЁЯТк р╣Гр╕Кр╣Йр╣Ар╕Чр╕Др╕Щр╕┤р╕Д Salt р╣Бр╕ер╕░ Iteration р╣Ар╕Юр╕╖р╣Ир╕нр╕Др╕зр╕▓р╕бр╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕вр╕кр╕╣р╕Зр╕кр╕╕р╕Ф!
struct PasswordHasher {
    base_hasher: Box<dyn Hasher>,
}

impl PasswordHasher {
    fn new(algorithm: HashAlgorithm) -> Self {
        let base_hasher: Box<dyn Hasher> = match algorithm {
            HashAlgorithm::Sha256 => Box::new(Sha256Hasher),
            HashAlgorithm::Sha512 => Box::new(Sha512Hasher),
            HashAlgorithm::Blake2b => Box::new(Blake2bHasher),
            _ => Box::new(Sha256Hasher), // Default
        };
        
        Self { base_hasher }
    }
    
    fn generate_salt(&self) -> Vec<u8> {
        // Simple salt generation (in real implementation, use crypto-secure random)
        let mut salt = Vec::new();
        let seed = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;
        
        for i in 0..32 {
            salt.push(((seed.wrapping_mul(i + 1)) % 256) as u8);
        }
        
        salt
    }
    
    fn hash_password(&self, password: &str, salt: &[u8], iterations: u32) -> PasswordHash {
        let mut current = password.as_bytes().to_vec();
        current.extend_from_slice(salt);
        
        // Perform iterations
        for _ in 0..iterations {
            let result = self.base_hasher.hash(&current);
            current = result.hash;
            current.extend_from_slice(salt); // Re-add salt for next iteration
        }
        
        // Final hash without salt
        let final_result = self.base_hasher.hash(&current[..current.len() - salt.len()]);
        
        PasswordHash::new(
            self.base_hasher.algorithm(),
            salt.to_vec(),
            final_result.hash,
            iterations,
        )
    }
    
    fn hash_password_with_salt(&self, password: &str, iterations: u32) -> PasswordHash {
        let salt = self.generate_salt();
        self.hash_password(password, &salt, iterations)
    }
}

/// ЁЯФР HMAC Generator - р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б
/// ЁЯЫбя╕П р╣Гр╕Кр╣Йр╕Др╕╡р╕вр╣Мр╕ер╕▒р╕Ър╣Ар╕Юр╕╖р╣Ир╕нр╕вр╕╖р╕Щр╕вр╕▒р╕Щр╕Др╕зр╕▓р╕бр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕Зр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б!
struct HmacGenerator {
    hasher: Box<dyn Hasher>,
    block_size: usize,
}

impl HmacGenerator {
    fn new(algorithm: HashAlgorithm) -> Self {
        let (hasher, block_size): (Box<dyn Hasher>, usize) = match algorithm {
            HashAlgorithm::Sha256 => (Box::new(Sha256Hasher), 64),
            HashAlgorithm::Sha512 => (Box::new(Sha512Hasher), 128),
            HashAlgorithm::Blake2b => (Box::new(Blake2bHasher), 128),
            _ => (Box::new(Sha256Hasher), 64),
        };
        
        Self { hasher, block_size }
    }
    
    fn generate(&self, key: &[u8], message: &[u8]) -> HashResult {
        let mut key = key.to_vec();
        
        // If key is longer than block size, hash it
        if key.len() > self.block_size {
            key = self.hasher.hash(&key).hash;
        }
        
        // Pad key to block size
        key.resize(self.block_size, 0);
        
        // Create inner and outer padding
        let mut ipad = vec![0x36; self.block_size];
        let mut opad = vec![0x5c; self.block_size];
        
        // XOR key with padding
        for i in 0..self.block_size {
            ipad[i] ^= key[i];
            opad[i] ^= key[i];
        }
        
        // Inner hash: H(K тКХ ipad || message)
        let mut inner_input = ipad;
        inner_input.extend_from_slice(message);
        let inner_hash = self.hasher.hash(&inner_input);
        
        // Outer hash: H(K тКХ opad || inner_hash)
        let mut outer_input = opad;
        outer_input.extend_from_slice(&inner_hash.hash);
        self.hasher.hash(&outer_input)
    }
    
    fn verify(&self, key: &[u8], message: &[u8], expected_hmac: &[u8]) -> bool {
        let computed_hmac = self.generate(key, message);
        
        // Constant-time comparison
        if computed_hmac.hash.len() != expected_hmac.len() {
            return false;
        }
        
        let mut result = 0u8;
        for (a, b) in computed_hmac.hash.iter().zip(expected_hmac.iter()) {
            result |= a ^ b;
        }
        
        result == 0
    }
}

/// тЬНя╕П р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Ир╕гр╕┤р╕Зр╣Бр╕Хр╣Ир╕Ыр╕ер╕нр╕бр╣Бр╕Ыр╕ер╕Зр╣Др╕бр╣Ир╣Др╕Фр╣Й
/// ЁЯФТ р╣Гр╕Кр╣Йр╕Др╕╣р╣Ир╕Бр╕╕р╕Нр╣Бр╕Ир╣Ар╕Юр╕╖р╣Ир╕нр╕вр╕╖р╕Щр╕вр╕▒р╕Щр╕Хр╕▒р╕зр╕Хр╕Щр╣Бр╕ер╕░р╕Др╕зр╕▓р╕бр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З!
#[derive(Debug, Clone)]
pub struct DigitalSignature {
    pub signature: Vec<u8>,
    pub algorithm: HashAlgorithm,
}

/// ЁЯЧЭя╕П р╕Др╕╣р╣Ир╕Бр╕╕р╕Нр╣Бр╕И - р╕Бр╕╕р╕Нр╣Бр╕Ир╕кр╕▓р╕Шр╕▓р╕гр╕Ур╕░р╣Бр╕ер╕░р╕Бр╕╕р╕Нр╣Бр╕Ир╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕з
/// ЁЯОн р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕бр╕╡р╕Бр╕╕р╕Нр╣Бр╕Ир╕кр╕│р╕лр╕гр╕▒р╕Ър╕ер╣Зр╕нр╕Др╣Бр╕ер╕░р╕Ыр╕ер╕Фр╕ер╣Зр╕нр╕Д!
#[derive(Debug, Clone)]
pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
}

/// тЬНя╕П р╕Ьр╕╣р╣Йр╕ер╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е - р╕Кр╣Ир╕▓р╕Зр╕Эр╕╡р╕бр╕╖р╕нр╕Фр╣Йр╕▓р╕Щр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щ
/// ЁЯОи р╕кр╕гр╣Йр╕▓р╕Зр╣Бр╕ер╕░р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Ыр╕ер╕нр╕бр╣Бр╕Ыр╕ер╕Зр╣Др╕Фр╣Й!
struct DigitalSigner {
    hasher: Box<dyn Hasher>,
}

impl DigitalSigner {
    fn new(algorithm: HashAlgorithm) -> Self {
        let hasher: Box<dyn Hasher> = match algorithm {
            HashAlgorithm::Sha256 => Box::new(Sha256Hasher),
            HashAlgorithm::Sha512 => Box::new(Sha512Hasher),
            _ => Box::new(Sha256Hasher),
        };
        
        Self { hasher }
    }
    
    fn generate_keypair(&self) -> KeyPair {
        // Simplified key generation (not cryptographically secure)
        let seed = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;
        
        let mut private_key = Vec::new();
        let mut public_key = Vec::new();
        
        // Generate private key
        for i in 0..32 {
            private_key.push(((seed.wrapping_mul(i + 1)) % 256) as u8);
        }
        
        // Generate public key from private key
        let private_hash = self.hasher.hash(&private_key);
        public_key = private_hash.hash;
        
        KeyPair {
            public_key,
            private_key,
        }
    }
    
    fn sign(&self, message: &[u8], private_key: &[u8]) -> DigitalSignature {
        // Hash the message
        let message_hash = self.hasher.hash(message);
        
        // "Encrypt" hash with private key (simplified)
        // In this simplified implementation, we'll derive the public key from private key
        let public_key_hash = self.hasher.hash(private_key);
        let public_key = &public_key_hash.hash;
        
        let mut signature = Vec::new();
        for (i, &hash_byte) in message_hash.hash.iter().enumerate() {
            let key_byte = public_key[i % public_key.len()];
            signature.push(hash_byte.wrapping_add(key_byte));
        }
        
        DigitalSignature {
            signature,
            algorithm: self.hasher.algorithm(),
        }
    }
    
    fn verify(&self, message: &[u8], signature: &DigitalSignature, public_key: &[u8]) -> bool {
        // Hash the message
        let message_hash = self.hasher.hash(message);
        
        // In this simplified implementation, we'll use the public key directly
        // to verify the signature (this is not how real digital signatures work)
        let mut decrypted = Vec::new();
        for (i, &sig_byte) in signature.signature.iter().enumerate() {
            let key_byte = public_key[i % public_key.len()];
            decrypted.push(sig_byte.wrapping_sub(key_byte));
        }
        
        // Compare with message hash
        decrypted == message_hash.hash
    }
}

/// ЁЯОЫя╕П р╕Хр╕▒р╕зр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╣Бр╕ор╕К - р╕ир╕╣р╕Щр╕вр╣Мр╕гр╕зр╕бр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╣Бр╕ор╕Кр╕Чр╕╕р╕Бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч
/// ЁЯФз р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕ер╣Ир╕нр╕Зр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╕Чр╕╡р╣Ир╕бр╕╡р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕бр╕╖р╕нр╕Др╕гр╕Ър╕Др╕гр╕▒р╕Щ!
pub struct HashManager {
    hashers: HashMap<HashAlgorithm, Box<dyn Hasher>>,
}

impl HashManager {
    fn new() -> Self {
        let mut hashers: HashMap<HashAlgorithm, Box<dyn Hasher>> = HashMap::new();
        
        hashers.insert(HashAlgorithm::Md5, Box::new(Md5Hasher));
        hashers.insert(HashAlgorithm::Sha256, Box::new(Sha256Hasher));
        hashers.insert(HashAlgorithm::Sha512, Box::new(Sha512Hasher));
        hashers.insert(HashAlgorithm::Blake2b, Box::new(Blake2bHasher));
        
        Self { hashers }
    }
    
    fn hash(&self, algorithm: HashAlgorithm, input: &[u8]) -> Option<HashResult> {
        self.hashers.get(&algorithm).map(|hasher| hasher.hash(input))
    }
    
    fn hash_string(&self, algorithm: HashAlgorithm, input: &str) -> Option<HashResult> {
        self.hash(algorithm, input.as_bytes())
    }
    
    fn verify_hash(&self, input: &[u8], expected: &HashResult) -> bool {
        if let Some(hasher) = self.hashers.get(&expected.algorithm) {
            let computed = hasher.hash(input);
            computed.hash == expected.hash
        } else {
            false
        }
    }
    
    fn compare_algorithms(&self, input: &[u8]) -> Vec<HashResult> {
        let mut results = Vec::new();
        
        for algorithm in [HashAlgorithm::Md5, HashAlgorithm::Sha256, HashAlgorithm::Sha512, HashAlgorithm::Blake2b] {
            if let Some(result) = self.hash(algorithm, input) {
                results.push(result);
            }
        }
        
        results
    }
}

/// ЁЯОУ р╕кр╕▓р╕Шр╕┤р╕Хр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Hashing р╣Бр╕ер╕░ Digital Signatures - р╣Ар╕зр╕┤р╕гр╣Мр╕Др╕Кр╣Зр╕нр╕Ыр╕Др╕зр╕▓р╕бр╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕в
pub fn demonstrate_hashing() {
    println!("ЁЯОп р╕вр╕┤р╕Щр╕Фр╕╡р╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╕кр╕╣р╣Ир╣Ар╕зр╕┤р╕гр╣Мр╕Др╕Кр╣Зр╕нр╕Ы 'р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е'! ЁЯФР");
    println!("ЁЯУЪ р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╣Ар╕гр╕▓р╕Ир╕░р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕зр╕┤р╕Шр╕╡р╕Ыр╕Бр╕Ыр╣Йр╕нр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Фр╣Йр╕зр╕вр╣Ар╕Чр╕Др╕Щр╕┤р╕Др╣Бр╕ор╕Кр╣Бр╕ер╕░р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е!");
    
    let manager = HashManager::new();
    
    // Basic Hashing
    println!("\nЁЯФи р╕Ър╕Чр╕Чр╕╡р╣И 1: р╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕ер╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щ");
    println!("ЁЯОи р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕Лр╣Йр╕│р╣Гр╕Др╕гр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е!");
    println!("{:-<60}", "");
    
    let test_data = "Hello, World!";
    println!("ЁЯУЭ р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Хр╣Йр╕Щр╕Йр╕Ър╕▒р╕Ъ: {test_data}");
    println!("ЁЯФН р╕бр╕▓р╕Фр╕╣р╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕Чр╕╡р╣Ир╕кр╕гр╣Йр╕▓р╕Зр╕Ир╕▓р╕Бр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Хр╣Ир╕▓р╕Зр╣Ж:");
    
    let results = manager.compare_algorithms(test_data.as_bytes());
    for result in results {
        println!("  ЁЯОп {result}");
    }
    
    // Hash Verification
    println!("\nЁЯФН р╕Ър╕Чр╕Чр╕╡р╣И 2: р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕Зр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е");
    println!("ЁЯЫбя╕П р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╣Ар╕нр╕Бр╕кр╕▓р╕гр╕Цр╕╣р╕Бр╣Бр╕Бр╣Йр╣Др╕Вр╕лр╕гр╕╖р╕нр╣Др╕бр╣И!");
    println!("{:-<60}", "");
    
    let original = "secret message";
    let sha256_hash = manager.hash_string(HashAlgorithm::Sha256, original).unwrap();
    
    println!("ЁЯУД р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Хр╣Йр╕Щр╕Йр╕Ър╕▒р╕Ъ: {original}");
    println!("ЁЯФР р╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕н SHA-256: {}", sha256_hash.hex_string);
    
    // Verify correct input
    let is_valid = manager.verify_hash(original.as_bytes(), &sha256_hash);
    println!("тЬЕ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З: {is_valid} ЁЯОЙ");
    
    // Verify incorrect input
    let is_invalid = manager.verify_hash(b"wrong message", &sha256_hash);
    println!("тЭМ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ьр╕┤р╕Ф: {is_invalid} тЪая╕П");
    
    // Password Hashing
    println!("\nЁЯФС р╕Ър╕Чр╕Чр╕╡р╣И 3: р╕Бр╕▓р╕гр╕Ыр╕Бр╕Ыр╣Йр╕нр╕Зр╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щр╕Фр╣Йр╕зр╕вр╣Ар╕Бр╕ер╕╖р╕нр╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Чр╕│р╕Лр╣Йр╕│");
    println!("ЁЯзВ р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╣Гр╕кр╣Ир╣Ар╕Бр╕ер╕╖р╕нр╣Гр╕Щр╕нр╕▓р╕лр╕▓р╕гр╣Ар╕Юр╕╖р╣Ир╕нр╣Гр╕лр╣Йр╕гр╕кр╕Кр╕▓р╕Хр╕┤р╣Др╕бр╣Ир╕Лр╣Йр╕│р╣Гр╕Др╕г!");
    println!("{:-<60}", "");
    
    let password_hasher = PasswordHasher::new(HashAlgorithm::Sha256);
    
    let password = "my_secure_password123";
    let password_hash = password_hasher.hash_password_with_salt(password, 10000);
    
    println!("ЁЯФР р╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щ: {password}");
    println!("ЁЯзВ р╣Ар╕Бр╕ер╕╖р╕н (Salt): {}", password_hash.salt.iter().map(|b| format!("{b:02x}")).collect::<String>());
    println!("ЁЯФТ р╣Бр╕ор╕Кр╕Чр╕╡р╣Ир╣Др╕Фр╣Й: {}", password_hash.hash.iter().map(|b| format!("{b:02x}")).collect::<String>());
    println!("ЁЯФД р╕Ир╕│р╕Щр╕зр╕Щр╕гр╕нр╕Ъ: {} р╕гр╕нр╕Ъ", password_hash.iterations);
    println!("ЁЯУж р╕гр╕лр╕▒р╕кр╕Чр╕╡р╣Ир╣Ар╕Вр╣Йр╕▓р╕гр╕лр╕▒р╕кр╣Бр╕ер╣Йр╕з: {}", password_hash.to_string());
    
    // Verify password
    let correct_password = password_hash.verify(password, &password_hasher);
    let wrong_password = password_hash.verify("wrong_password", &password_hasher);
    
    println!("тЬЕ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З: {correct_password} ЁЯОп");
    println!("тЭМ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕гр╕лр╕▒р╕кр╕Ьр╣Ир╕▓р╕Щр╕Ьр╕┤р╕Ф: {wrong_password} ЁЯЪл");
    
    // HMAC
    println!("\nЁЯФР р╕Ър╕Чр╕Чр╕╡р╣И 4: HMAC - р╕Бр╕▓р╕гр╕вр╕╖р╕Щр╕вр╕▒р╕Щр╕Хр╕▒р╕зр╕Хр╕Щр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б");
    println!("ЁЯЫбя╕П р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╣Гр╕кр╣Ир╕Хр╕гр╕▓р╕Ыр╕гр╕░р╕Чр╕▒р╕Ър╕ер╕▒р╕Ър╕Чр╕╡р╣Ир╕бр╕╡р╣Ар╕Юр╕╡р╕вр╕Зр╣Ар╕гр╕▓р╣Ар╕Чр╣Ир╕▓р╕Щр╕▒р╣Йр╕Щр╕Чр╕╡р╣Ир╕гр╕╣р╣Й!");
    println!("{:-<60}", "");
    
    let hmac_generator = HmacGenerator::new(HashAlgorithm::Sha256);
    let key = b"secret_key";
    let message = b"important message";
    
    let hmac = hmac_generator.generate(key, message);
    println!("ЁЯЧЭя╕П р╕Бр╕╕р╕Нр╣Бр╕Ир╕ер╕▒р╕Ъ: {}", String::from_utf8_lossy(key));
    println!("ЁЯУЭ р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б: {}", String::from_utf8_lossy(message));
    println!("ЁЯФР р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щ HMAC: {}", hmac.hex_string);
    
    // Verify HMAC
    let valid_hmac = hmac_generator.verify(key, message, &hmac.hash);
    let invalid_hmac = hmac_generator.verify(b"wrong_key", message, &hmac.hash);
    
    println!("тЬЕ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ HMAC р╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З: {valid_hmac} ЁЯОЙ");
    println!("тЭМ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ HMAC р╕Ьр╕┤р╕Ф: {invalid_hmac} тЪая╕П");
    
    // Digital Signatures
    println!("\nтЬНя╕П р╕Ър╕Чр╕Чр╕╡р╣И 5: р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е - р╕Бр╕▓р╕гр╕вр╕╖р╕Щр╕вр╕▒р╕Щр╕Хр╕▒р╕зр╕Хр╕Щр╣Бр╕Ър╕Ър╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е");
    println!("ЁЯОн р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Ир╕гр╕┤р╕Зр╣Бр╕Хр╣Ир╕Ыр╕ер╕нр╕бр╣Бр╕Ыр╕ер╕Зр╣Др╕бр╣Ир╣Др╕Фр╣Й!");
    println!("{:-<60}", "");
    
    let signer = DigitalSigner::new(HashAlgorithm::Sha256);
    let keypair = signer.generate_keypair();
    
    println!("ЁЯФУ р╕Бр╕╕р╕Нр╣Бр╕Ир╕кр╕▓р╕Шр╕▓р╕гр╕Ур╕░: {}", keypair.public_key.iter().map(|b| format!("{b:02x}")).collect::<String>());
    println!("ЁЯФР р╕Бр╕╕р╕Нр╣Бр╕Ир╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕з: {}... (р╣Ар╕Бр╣Зр╕Ър╣Ар╕Ыр╣Зр╕Щр╕Др╕зр╕▓р╕бр╕ер╕▒р╕Ъ!)", keypair.private_key[..8].iter().map(|b| format!("{b:02x}")).collect::<String>());
    
    let document = b"This is an important document that needs to be signed.";
    let signature = signer.sign(document, &keypair.private_key);
    
    println!("ЁЯУД р╣Ар╕нр╕Бр╕кр╕▓р╕г: {}", String::from_utf8_lossy(document));
    println!("тЬНя╕П р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е: {}", signature.signature.iter().map(|b| format!("{b:02x}")).collect::<String>());
    
    // Verify signature
    let valid_signature = signer.verify(document, &signature, &keypair.public_key);
    let invalid_signature = signer.verify(b"tampered document", &signature, &keypair.public_key);
    
    println!("тЬЕ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З: {valid_signature} ЁЯОп");
    println!("тЭМ р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Ар╕нр╕Бр╕кр╕▓р╕гр╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╣Бр╕Бр╣Йр╣Др╕В: {invalid_signature} ЁЯЪи");
    
    // File Integrity Check
    println!("\nЁЯУБ р╕Ър╕Чр╕Чр╕╡р╣И 6: р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕кр╕бр╕Ър╕╣р╕гр╕Ур╣Мр╕Вр╕нр╕Зр╣Др╕Яр╕ер╣М");
    println!("ЁЯЫбя╕П р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╣Др╕Яр╕ер╣Мр╕Цр╕╣р╕Бр╣Бр╕Бр╣Йр╣Др╕Вр╕лр╕гр╕╖р╕нр╣Др╕бр╣И!");
    println!("{:-<60}", "");
    
    let file_content = b"This is the content of an important file.\nIt contains sensitive data.\nWe need to ensure its integrity.";
    let file_hashes = manager.compare_algorithms(file_content);
    
    println!("ЁЯУД р╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╣Др╕Яр╕ер╣М ({} р╣Др╕Ър╕Хр╣М):", file_content.len());
    println!("{}", String::from_utf8_lossy(file_content));
    println!("\nЁЯФР р╕ер╕▓р╕вр╕Щр╕┤р╣Йр╕зр╕бр╕╖р╕нр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕кр╕бр╕Ър╕╣р╕гр╕Ур╣М:");
    
    for hash in file_hashes {
        println!("  ЁЯОп {hash}");
    }
    
    // Simulate file modification
    let modified_content = b"This is the content of an important file.\nIt contains MODIFIED data.\nWe need to ensure its integrity.";
    let modified_hash = manager.hash(HashAlgorithm::Sha256, modified_content).unwrap();
    let original_hash = manager.hash(HashAlgorithm::Sha256, file_content).unwrap();
    
    println!("\nЁЯФН р╕Ьр╕ер╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕кр╕бр╕Ър╕╣р╕гр╕Ур╣М:");
    println!("ЁЯУД р╣Др╕Яр╕ер╣Мр╕Хр╣Йр╕Щр╕Йр╕Ър╕▒р╕Ъ SHA-256:  {}", original_hash.hex_string);
    println!("ЁЯУЭ р╣Др╕Яр╕ер╣Мр╕Чр╕╡р╣Ир╣Бр╕Бр╣Йр╣Др╕В SHA-256:  {}", modified_hash.hex_string);
    println!("ЁЯОп р╣Др╕Яр╕ер╣Мр╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▒р╕Щ: {} {}", original_hash.hash == modified_hash.hash, if original_hash.hash == modified_hash.hash { "тЬЕ" } else { "тЭМ" });
    
    // Performance Comparison
    println!("\nтЪб р╕Ър╕Чр╕Чр╕╡р╣И 7: р╕Бр╕▓р╕гр╣Ар╕Ыр╕гр╕╡р╕вр╕Ър╣Ар╕Чр╕╡р╕вр╕Ър╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю");
    println!("ЁЯПГтАНтЩВя╕П р╕бр╕▓р╕Фр╕╣р╕Бр╕▒р╕Щр╕зр╣Ир╕▓р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╣Др╕лр╕Щр╣Ар╕гр╣Зр╕зр╕Чр╕╡р╣Ир╕кр╕╕р╕Ф!");
    println!("{:-<60}", "");
    
    let large_data = vec![0u8; 10000]; // 10KB of data
    println!("ЁЯУК р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▒р╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е 10KB:");
    
    for algorithm in [HashAlgorithm::Md5, HashAlgorithm::Sha256, HashAlgorithm::Sha512, HashAlgorithm::Blake2b] {
        let start = std::time::Instant::now();
        let result = manager.hash(algorithm.clone(), &large_data).unwrap();
        let duration = start.elapsed();
        
        println!("ЁЯЪА {:?}: {} ({}╬╝s)", 
                algorithm, 
                &result.hex_string[..16], 
                duration.as_micros());
    }
    
    println!("\nЁЯОЙ р╕вр╕┤р╕Щр╕Фр╕╡р╕Фр╣Йр╕зр╕в! р╕Др╕╕р╕Ур╣Др╕Фр╣Йр╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╣Ар╕Чр╕Др╕Щр╕┤р╕Др╕Бр╕▓р╕гр╣Бр╕ор╕Кр╣Бр╕ер╕░р╕ер╕▓р╕вр╣Ар╕Лр╣Зр╕Щр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕ер╣Ар╕гр╕╡р╕вр╕Ър╕гр╣Йр╕нр╕вр╣Бр╕ер╣Йр╕з!");
    println!("ЁЯТб р╕Хр╕нр╕Щр╕Щр╕╡р╣Йр╕Др╕╕р╕Ур╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Ыр╕Бр╕Ыр╣Йр╕нр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕ер╕░р╕вр╕╖р╕Щр╕вр╕▒р╕Щр╕Хр╕▒р╕зр╕Хр╕Щр╣Др╕Фр╣Йр╣Бр╕ер╣Йр╕з! ЁЯФР");
    println!("ЁЯЫбя╕П р╕Ир╕│р╣Др╕зр╣Й: р╕Др╕зр╕▓р╕бр╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕вр╕Др╕╖р╕нр╕кр╕┤р╣Ир╕Зр╕кр╕│р╕Др╕▒р╕Нр╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╣Гр╕Щр╣Вр╕ер╕Бр╕Фр╕┤р╕Ир╕┤р╕Чр╕▒р╕е!");
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_hash_consistency() {
        let hasher = Sha256Hasher;
        let input = b"test input";
        
        let hash1 = hasher.hash(input);
        let hash2 = hasher.hash(input);
        
        assert_eq!(hash1.hash, hash2.hash);
        assert_eq!(hash1.hex_string, hash2.hex_string);
    }
    
    #[test]
    fn test_hash_verification() {
        let hasher = Sha256Hasher;
        let input = b"test message";
        let hash_result = hasher.hash(input);
        
        assert!(hash_result.verify(input, &hasher));
        assert!(!hash_result.verify(b"different message", &hasher));
    }
    
    #[test]
    fn test_password_hashing() {
        let hasher = PasswordHasher::new(HashAlgorithm::Sha256);
        let password = "test_password";
        
        let hash1 = hasher.hash_password_with_salt(password, 1000);
        let hash2 = hasher.hash_password_with_salt(password, 1000);
        
        // Different salts should produce different hashes
        assert_ne!(hash1.hash, hash2.hash);
        
        // But both should verify correctly
        assert!(hash1.verify(password, &hasher));
        assert!(hash2.verify(password, &hasher));
    }
    
    #[test]
    fn test_hmac() {
        let hmac_gen = HmacGenerator::new(HashAlgorithm::Sha256);
        let key = b"test_key";
        let message = b"test_message";
        
        let hmac = hmac_gen.generate(key, message);
        
        assert!(hmac_gen.verify(key, message, &hmac.hash));
        assert!(!hmac_gen.verify(b"wrong_key", message, &hmac.hash));
        assert!(!hmac_gen.verify(key, b"wrong_message", &hmac.hash));
    }
    
    #[test]
    fn test_digital_signature() {
        let signer = DigitalSigner::new(HashAlgorithm::Sha256);
        let keypair = signer.generate_keypair();
        let message = b"test document";
        
        let signature = signer.sign(message, &keypair.private_key);
        
        assert!(signer.verify(message, &signature, &keypair.public_key));
        assert!(!signer.verify(b"tampered message", &signature, &keypair.public_key));
    }
}