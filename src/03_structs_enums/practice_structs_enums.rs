//! Practice Structs and Enums - à¹à¸šà¸šà¸à¸¶à¸à¸«à¸±à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ Structs à¹à¸¥à¸° Enums
//!
//! à¹„à¸Ÿà¸¥à¹Œà¸™à¸µà¹‰à¸¡à¸µà¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ Structs à¹à¸¥à¸° Enums à¹ƒà¸™à¸ªà¸–à¸²à¸™à¸à¸²à¸£à¸“à¹Œà¸ˆà¸£à¸´à¸‡
//! à¹€à¸Šà¹ˆà¸™ à¸£à¸°à¸šà¸šà¸ˆà¸±à¸”à¸à¸²à¸£à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­, à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸„à¸´à¸”à¹€à¸¥à¸‚ à¹à¸¥à¸°à¸£à¸°à¸šà¸šà¹ƒà¸«à¹‰à¸„à¸°à¹à¸™à¸™à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™
//! (à¸ªà¸§à¸™à¸ªà¸™à¸¸à¸à¹à¸«à¹ˆà¸‡à¸à¸²à¸£à¹€à¸‚à¸µà¸¢à¸™à¹‚à¸›à¸£à¹à¸à¸£à¸¡! ğŸ¢)

/// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸¶à¸à¸à¸™ Structs à¹à¸¥à¸° Enums
/// à¸¡à¸²à¸—à¸³à¹à¸šà¸šà¸à¸¶à¸à¸«à¸±à¸”à¸à¸±à¸™à¹€à¸–à¸­à¸°! (à¸¢à¸´à¸¡à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸¡à¸­à¸‡à¹‚à¸›à¸£à¹à¸à¸£à¸¡à¹€à¸¡à¸­à¸£à¹Œ! ğŸ§ ğŸ’ª)
#[allow(clippy::too_many_lines)]
pub fn practice_structs_and_enums() {
    println!("\nğŸ’ª === à¹à¸šà¸šà¸à¸¶à¸à¸«à¸±à¸” Structs à¹à¸¥à¸° Enums: à¸ªà¸§à¸™à¸ªà¸™à¸¸à¸à¹‚à¸›à¸£à¹à¸à¸£à¸¡! === ğŸ’ª");

    // 1. Book Management System (à¸«à¹‰à¸­à¸‡à¸ªà¸¡à¸¸à¸”à¹à¸«à¹ˆà¸‡à¸­à¸™à¸²à¸„à¸•! ğŸ“š)
    #[derive(Debug, Clone)]
    #[allow(dead_code)]
    struct Book {
        title: String,     // à¸Šà¸·à¹ˆà¸­à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸ªà¸¸à¸”à¹€à¸—à¹ˆ! ğŸ“–
        author: String,    // à¸™à¸±à¸à¹€à¸‚à¸µà¸¢à¸™à¸œà¸¹à¹‰à¸¢à¸´à¹ˆà¸‡à¹ƒà¸«à¸à¹ˆ! âœï¸
        pages: u32,        // à¸ˆà¸³à¸™à¸§à¸™à¸«à¸™à¹‰à¸²à¸„à¸§à¸²à¸¡à¸£à¸¹à¹‰! ğŸ“„
        available: bool,   // à¸ªà¸–à¸²à¸™à¸°à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰! ğŸŸ¢
    }

    impl Book {
        const fn new(title: String, author: String, pages: u32) -> Self {  // à¹‚à¸£à¸‡à¸‡à¸²à¸™à¸œà¸¥à¸´à¸•à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­! ğŸ­
            Self {
                title,
                author,
                pages,
                available: true,  // à¹€à¸à¸´à¸”à¸¡à¸²à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰! âœ¨
            }
        }

        fn borrow_book(&mut self) -> Result<(), String> {  // à¹€à¸ˆà¹‰à¸²à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¹ƒà¸«à¹‰à¸¢à¸·à¸¡! ğŸ‘©â€ğŸ’¼
            if self.available {
                self.available = false;  // à¸•à¸´à¸”à¸›à¹‰à¸²à¸¢ "à¹„à¸¡à¹ˆà¸§à¹ˆà¸²à¸‡"! ğŸš«
                Ok(())  // à¸¢à¸·à¸¡à¹„à¸”à¹‰! ğŸ‰
            } else {
                Err(String::from("à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­à¹„à¸¡à¹ˆà¸§à¹ˆà¸²à¸‡"))  // à¸‚à¸­à¸­à¸ à¸±à¸¢ à¹€à¸•à¹‡à¸¡à¹à¸¥à¹‰à¸§! ğŸ˜…
            }
        }

        const fn return_book(&mut self) {  // à¹€à¸ˆà¹‰à¸²à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸£à¸±à¸šà¸„à¸·à¸™! ğŸ‘¨â€ğŸ’¼
            self.available = true;  // à¸•à¸´à¸”à¸›à¹‰à¸²à¸¢ "à¸§à¹ˆà¸²à¸‡"! âœ…
        }
    }

    println!("ğŸ“š === à¸£à¸°à¸šà¸šà¸ˆà¸±à¸”à¸à¸²à¸£à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­: à¸«à¹‰à¸­à¸‡à¸ªà¸¡à¸¸à¸”à¹à¸«à¹ˆà¸‡à¸­à¸™à¸²à¸„à¸•! === ğŸ“š");
    let mut book1 = Book::new(
        String::from("The Rust Programming Language"),  // à¸„à¸±à¸¡à¸ à¸µà¸£à¹Œà¹à¸«à¹ˆà¸‡à¸à¸²à¸£à¹€à¸‚à¸µà¸¢à¸™à¹‚à¸›à¸£à¹à¸à¸£à¸¡! ğŸ“œ
        String::from("Steve Klabnik"),                  // à¸­à¸²à¸ˆà¸²à¸£à¸¢à¹Œà¹ƒà¸«à¸à¹ˆ! ğŸ§™â€â™‚ï¸
        552,                                            // à¸«à¸™à¹‰à¸²à¹€à¸à¸µà¸¢à¸š! ğŸ“š
    );

    println!("ğŸ“– à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­: {book1:?} (à¸ªà¸¡à¸šà¸±à¸•à¸´à¸¥à¹‰à¸³à¸„à¹ˆà¸²! ğŸ’)");

    match book1.borrow_book() {  // à¸¥à¸¹à¸à¸„à¹‰à¸²à¸„à¸™à¹à¸£à¸! ğŸ‘¤
        Ok(()) => println!("âœ… à¸¢à¸·à¸¡à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­à¸ªà¸³à¹€à¸£à¹‡à¸ˆ (à¹‚à¸Šà¸„à¸”à¸µ! ğŸ€)"),
        Err(e) => println!("âŒ {e} (à¹€à¸ªà¸µà¸¢à¹ƒà¸ˆà¸”à¹‰à¸§à¸¢! ğŸ˜¢)"),
    }

    match book1.borrow_book() {  // à¸¥à¸¹à¸à¸„à¹‰à¸²à¸„à¸™à¸—à¸µà¹ˆà¸ªà¸­à¸‡! ğŸ‘¥
        Ok(()) => println!("âœ… à¸¢à¸·à¸¡à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­à¸ªà¸³à¹€à¸£à¹‡à¸ˆ (à¹‚à¸Šà¸„à¸”à¸µ! ğŸ€)"),
        Err(e) => println!("âŒ {e} (à¸¡à¸²à¸Šà¹‰à¸²à¹„à¸›! â°)"),
    }

    book1.return_book();  // à¸„à¸·à¸™à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­! ğŸ“š
    println!("ğŸ“š à¸„à¸·à¸™à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­à¹à¸¥à¹‰à¸§ (à¸‚à¸­à¸šà¸„à¸¸à¸“à¸„à¹ˆà¸°! ğŸ™)");

    // 2. Calculator with Enums (à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸„à¸´à¸”à¹€à¸¥à¸‚à¹à¸«à¹ˆà¸‡à¸­à¸™à¸²à¸„à¸•! ğŸ§®)
    #[derive(Debug)]
    enum Operation {
        Add(f64, f64),      // à¸šà¸§à¸à¸ªà¸™à¸¸à¸! â•
        Subtract(f64, f64), // à¸¥à¸šà¹€à¸à¹ˆà¸‡! â–
        Multiply(f64, f64), // à¸„à¸¹à¸“à¹€à¸—à¹ˆ! âœ–ï¸
        Divide(f64, f64),   // à¸«à¸²à¸£à¹€à¸ˆà¹‹à¸‡! â—
    }

    impl Operation {
        fn calculate(&self) -> Result<f64, String> {  // à¸™à¸±à¸à¸„à¸“à¸´à¸•à¸¨à¸²à¸ªà¸•à¸£à¹Œà¸•à¸±à¸§à¸ˆà¸´à¹‹à¸§! ğŸ¤“
            match self {
                Self::Add(a, b) => Ok(a + b),      // à¸šà¸§à¸à¸‡à¹ˆà¸²à¸¢à¹†! ğŸ¯
                Self::Subtract(a, b) => Ok(a - b), // à¸¥à¸šà¸ªà¸šà¸²à¸¢! ğŸ˜Œ
                Self::Multiply(a, b) => Ok(a * b), // à¸„à¸¹à¸“à¸„à¸¥à¹ˆà¸­à¸‡! ğŸš€
                Self::Divide(a, b) => {           // à¸«à¸²à¸£à¸£à¸°à¸§à¸±à¸‡! âš ï¸
                    if *b == 0.0 {
                        Err(String::from("à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸«à¸²à¸£à¸”à¹‰à¸§à¸¢à¸¨à¸¹à¸™à¸¢à¹Œà¹„à¸”à¹‰"))  // à¸­à¸±à¸™à¸•à¸£à¸²à¸¢! ğŸ’¥
                    } else {
                        Ok(a / b)  // à¸«à¸²à¸£à¹„à¸”à¹‰! ğŸ‰
                    }
                }
            }
        }
    }

    println!("\nğŸ§® === à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸„à¸´à¸”à¹€à¸¥à¸‚: à¸¨à¸¹à¸™à¸¢à¹Œà¸£à¸§à¸¡à¸„à¸“à¸´à¸•à¸¨à¸²à¸ªà¸•à¸£à¹Œ! === ğŸ§®");
    let operations = vec![
        Operation::Add(10.0, 5.0),      // à¸šà¸§à¸à¸‡à¹ˆà¸²à¸¢à¹†! ğŸ¯
        Operation::Subtract(10.0, 3.0), // à¸¥à¸šà¸ªà¸šà¸²à¸¢! ğŸ˜Œ
        Operation::Multiply(4.0, 7.0),  // à¸„à¸¹à¸“à¸„à¸¥à¹ˆà¸­à¸‡! ğŸš€
        Operation::Divide(15.0, 3.0),   // à¸«à¸²à¸£à¸¥à¸·à¹ˆà¸™! âœ¨
        Operation::Divide(10.0, 0.0),   // à¸«à¸²à¸£à¸­à¸±à¸™à¸•à¸£à¸²à¸¢! ğŸ’£ (à¸ˆà¸°à¹€à¸à¸´à¸”à¸­à¸°à¹„à¸£à¸‚à¸¶à¹‰à¸™?)
    ];

    for op in operations {
        match op.calculate() {  // à¸—à¸”à¸ªà¸­à¸šà¸„à¸§à¸²à¸¡à¸ªà¸²à¸¡à¸²à¸£à¸–! ğŸ§ª
            Ok(result) => println!("âœ… {op:?} = {result} (à¹€à¸à¹ˆà¸‡à¸¡à¸²à¸! ğŸŒŸ)"),
            Err(error) => println!("âŒ {op:?} -> {error} (à¹‚à¸­à¹Šà¸°à¹‚à¸­! ğŸ˜±)"),
        }
    }

    // 3. Student Grading System (à¸£à¸°à¸šà¸šà¹ƒà¸«à¹‰à¸„à¸°à¹à¸™à¸™à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™! ğŸ“)
    #[derive(Debug)]
    enum Grade {
        A,  // à¹€à¸—à¸! ğŸ‘‘
        B,  // à¹€à¸à¹ˆà¸‡! ğŸŒŸ
        C,  // à¹‚à¸­à¹€à¸„! ğŸ‘
        D,  // à¸­à¸¸à¹Šà¸›à¸ªà¹Œ! ğŸ˜…
        F,  // à¸­à¹Šà¸°! ğŸ˜±
    }

    impl Grade {
        const fn from_score(score: u8) -> Self {  // à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¹à¸›à¸¥à¸‡à¸„à¸°à¹à¸™à¸™! ğŸ”„
            match score {
                90..=100 => Self::A,  // à¹€à¸—à¸à¸£à¸°à¸”à¸±à¸š! ğŸ†
                80..=89 => Self::B,   // à¹€à¸à¹ˆà¸‡à¸¡à¸²à¸! ğŸ¥ˆ
                70..=79 => Self::C,   // à¸œà¹ˆà¸²à¸™à¹„à¸”à¹‰! ğŸ¥‰
                60..=69 => Self::D,   // à¹€à¸®à¹‰à¸­... ğŸ˜“
                _ => Self::F,         // à¸­à¹Šà¸°... ğŸ’€
            }
        }

        const fn to_gpa(&self) -> f32 {  // à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ GPA! ğŸ“Š
            match self {
                Self::A => 4.0,  // à¹€à¸•à¹‡à¸¡! ğŸ’¯
                Self::B => 3.0,  // à¸”à¸µ! ğŸ˜Š
                Self::C => 2.0,  // à¹‚à¸­à¹€à¸„! ğŸ˜
                Self::D => 1.0,  // à¸­à¸¸à¹Šà¸¢! ğŸ˜¬
                Self::F => 0.0,  // à¹‚à¸­à¹Šà¸°à¹‚à¸­! ğŸ˜µ
            }
        }
    }

    #[derive(Debug)]
    #[allow(dead_code)]
    struct Student {
        name: String,     // à¸Šà¸·à¹ˆà¸­à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™! ğŸ‘¨â€ğŸ“
        scores: Vec<u8>,  // à¸„à¸¥à¸±à¸‡à¸„à¸°à¹à¸™à¸™! ğŸ“š
    }

    impl Student {
        const fn new(name: String) -> Self {  // à¹‚à¸£à¸‡à¸‡à¸²à¸™à¸œà¸¥à¸´à¸•à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™! ğŸ­
            Self {
                name,
                scores: Vec::new(),  // à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸”à¹‰à¸§à¸¢à¸„à¸°à¹à¸™à¸™à¹€à¸›à¸¥à¹ˆà¸²! ğŸ“
            }
        }

        fn add_score(&mut self, score: u8) {  // à¹€à¸à¸´à¹ˆà¸¡à¸„à¸°à¹à¸™à¸™! â•
            self.scores.push(score);  // à¹ƒà¸ªà¹ˆà¸„à¸°à¹à¸™à¸™à¹€à¸‚à¹‰à¸²à¹„à¸›! ğŸ“Š
        }

        fn calculate_gpa(&self) -> f32 {  // à¸„à¸³à¸™à¸§à¸“ GPA! ğŸ§®
            if self.scores.is_empty() {
                return 0.0;  // à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¸°à¹à¸™à¸™ = 0! ğŸ˜…
            }

            let total_gpa: f32 = self
                .scores
                .iter()
                .map(|&score| Grade::from_score(score).to_gpa())  // à¸£à¸§à¸¡à¸„à¸°à¹à¸™à¸™ GPA! ğŸ“ˆ
                .sum();

            total_gpa / self.scores.len() as f32  // à¸«à¸²à¸„à¹ˆà¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢! ğŸ“Š
        }

        fn get_grades(&self) -> Vec<Grade> {  // à¹à¸›à¸¥à¸‡à¸„à¸°à¹à¸™à¸™à¹€à¸›à¹‡à¸™à¹€à¸à¸£à¸”! ğŸ”„
            self.scores
                .iter()
                .map(|&score| Grade::from_score(score))  // à¹€à¸§à¸—à¸¡à¸™à¸•à¸£à¹Œà¹à¸›à¸¥à¸‡à¸„à¸°à¹à¸™à¸™! âœ¨
                .collect()
        }
    }

    println!("\nğŸ“ === à¸£à¸°à¸šà¸šà¹ƒà¸«à¹‰à¸„à¸°à¹à¸™à¸™à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™: à¹‚à¸£à¸‡à¹€à¸£à¸µà¸¢à¸™à¹à¸«à¹ˆà¸‡à¸„à¸§à¸²à¸¡à¸ªà¸™à¸¸à¸! === ğŸ“");
    let mut student = Student::new(String::from("à¸ªà¸¡à¸Šà¸²à¸¢"));  // à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡! ğŸ‘¨â€ğŸ“

    student.add_score(85);  // à¸„à¸°à¹à¸™à¸™à¸”à¸µ! ğŸ˜Š
    student.add_score(92);  // à¹€à¸à¹ˆà¸‡à¸¡à¸²à¸! ğŸŒŸ
    student.add_score(78);  // à¹‚à¸­à¹€à¸„à¸™à¸°! ğŸ‘
    student.add_score(88);  // à¹€à¸¢à¸µà¹ˆà¸¢à¸¡! ğŸ‰

    println!("ğŸ‘¤ à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™: {student:?} (à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™à¸”à¸µà¹€à¸”à¹ˆà¸™! â­)");
    println!("ğŸ“Š à¹€à¸à¸£à¸”: {:?} (à¸œà¸¥à¸‡à¸²à¸™à¸ªà¸¸à¸”à¹€à¸ˆà¹‹à¸‡! ğŸ†)", student.get_grades());
    println!("ğŸ¯ GPA: {:.2} (à¸„à¸°à¹à¸™à¸™à¸„à¸§à¸²à¸¡à¹€à¸à¹ˆà¸‡! ğŸ“ˆ)", student.calculate_gpa());

    println!("\nğŸ‰ à¸ˆà¸šà¹à¸šà¸šà¸à¸¶à¸à¸«à¸±à¸” Structs à¹à¸¥à¸° Enums: à¸‚à¸­à¹à¸ªà¸”à¸‡à¸„à¸§à¸²à¸¡à¸¢à¸´à¸™à¸”à¸µ! ğŸŠ");
    println!("ğŸ† à¸„à¸¸à¸“à¹„à¸”à¹‰à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ Structs à¹à¸¥à¸° Enums à¹à¸¥à¹‰à¸§! (à¹€à¸à¹ˆà¸‡à¸¡à¸²à¸! ğŸ‘)");
}
