//! Enums - р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Enums р╣Гр╕Щ Rust
//!
//! р╣Др╕Яр╕ер╣Мр╕Щр╕╡р╣Йр╕кр╕нр╕Щр╣Ар╕гр╕╖р╣Ир╕нр╕Зр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╣Бр╕ер╕░р╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Enums р╣Гр╕Щр╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╕Хр╣Ир╕▓р╕Зр╣Ж
//! р╕гр╕зр╕бр╕Цр╕╢р╕З Basic Enums, Enums with Data, Option, Result р╣Бр╕ер╕░ Pattern Matching
//! (р╕гр╣Йр╕▓р╕Щр╕Вр╕▓р╕вр╕Хр╕▒р╕зр╣Ар╕ер╕╖р╕нр╕Бр╣Бр╕лр╣Ир╕Зр╣Ар╕Фр╕╡р╕вр╕зр╣Гр╕Щр╕Ир╕▒р╕Бр╕гр╕зр╕▓р╕е! ЁЯЫТ)

/// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕кр╕нр╕Щр╣Ар╕гр╕╖р╣Ир╕нр╕З Enums
/// р╕бр╕▓р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╣Бр╕ер╕░р╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Enums р╕Бр╕▒р╕Щр╣Ар╕Цр╕нр╕░! (р╣Ар╕бр╕Щр╕╣р╕нр╕▓р╕лр╕▓р╕гр╣Бр╕лр╣Ир╕Зр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕б! ЁЯУЛ)
pub fn learn_enums() {
    println!("\nЁЯОп === Enums р╣Гр╕Щ Rust: р╕гр╣Йр╕▓р╕Щр╕Вр╕▓р╕вр╕Хр╕▒р╕зр╣Ар╕ер╕╖р╕нр╕Б! === ЁЯОп");

    // Basic Enums (р╣Ар╕бр╕Щр╕╣р╕нр╕▓р╕лр╕▓р╕гр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щ! ЁЯН╜я╕П)
    #[derive(Debug)]
    enum IpAddrKind {
        V4,  // р╕гр╕╕р╣Ир╕Щр╕Др╕ер╕▓р╕кр╕кр╕┤р╕Д! ЁЯУ╗
        V6,  // р╕гр╕╕р╣Ир╕Щр╣Гр╕лр╕бр╣Ир╕ер╣Ир╕▓р╕кр╕╕р╕Ф! ЁЯЪА
    }

    println!("ЁЯМР === Basic Enums: р╣Ар╕бр╕Щр╕╣р╕Чр╕╡р╣Ир╕нр╕вр╕╣р╣Ир╕нр╕┤р╕Щр╣Ар╕Чр╕нр╕гр╣Мр╣Ар╕Щр╣Зр╕Х! === ЁЯМР");
    let four = IpAddrKind::V4;  // р╕кр╕▒р╣Ир╕Зр╕гр╕╕р╣Ир╕Щр╕Др╕ер╕▓р╕кр╕кр╕┤р╕Д! ЁЯУЮ
    let six = IpAddrKind::V6;   // р╕кр╕▒р╣Ир╕Зр╕гр╕╕р╣Ир╕Щр╣Гр╕лр╕бр╣И! ЁЯУ▒

    println!("тЬЕ IPv4: {four:?} (р╕гр╕╕р╣Ир╕Щр╕Др╕ер╕▓р╕кр╕кр╕┤р╕Др╕Чр╕╡р╣Ир╕Чр╕╕р╕Бр╕Др╕Щр╕гр╕╣р╣Йр╕Ир╕▒р╕Б! ЁЯС┤)");
    println!("тЬЕ IPv6: {six:?} (р╕гр╕╕р╣Ир╕Щр╣Гр╕лр╕бр╣Ир╕кр╕│р╕лр╕гр╕▒р╕Ър╕нр╕Щр╕▓р╕Др╕Х! ЁЯФо)");

    // Enums with data (р╣Ар╕бр╕Щр╕╣р╕Юр╕┤р╣Ар╕ир╕йр╕бр╕╡р╕Вр╕нр╕Зр╣Бр╕Цр╕б! ЁЯОБ)
    #[derive(Debug)]
    enum IpAddr {
        V4(u8, u8, u8, u8),  // р╣Ар╕Лр╣Зр╕Хр╕кр╕╡р╣Ир╕Кр╕┤р╣Йр╕Щ! ЁЯН▒
        V6(String),          // р╣Ар╕бр╕Щр╕╣р╕Юр╕┤р╣Ар╕ир╕йр╣Бр╕Ър╕Ър╕вр╕▓р╕з! ЁЯНЬ
    }

    // р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ IpAddr enum (р╕Юр╕Щр╕▒р╕Бр╕Зр╕▓р╕Щр╣Ар╕кр╕┤р╕гр╣Мр╕Яр╕бр╕╖р╕нр╕нр╕▓р╕Кр╕╡р╕Ю! ЁЯСитАНЁЯН│)
    fn display_ip_info(addr: &IpAddr) {
        match addr {
            IpAddr::V4(a, b, c, d) => println!("ЁЯМР IPv4 Address: {a}.{b}.{c}.{d} (р╣Ар╕Лр╣Зр╕Хр╕кр╕╡р╣Ир╕Кр╕┤р╣Йр╕Щр╕Юр╕гр╣Йр╕нр╕бр╣Ар╕кр╕┤р╕гр╣Мр╕Я! ЁЯН▒)"),
            IpAddr::V6(addr) => println!("ЁЯМР IPv6 Address: {addr} (р╣Ар╕бр╕Щр╕╣р╕Юр╕┤р╣Ар╕ир╕йр╣Бр╕Ър╕Ър╕вр╕▓р╕з! ЁЯНЬ)"),
        }
    }

    println!("\nЁЯУж === Enums with Data: р╣Ар╕бр╕Щр╕╣р╕Юр╕┤р╣Ар╕ир╕йр╕бр╕╡р╕Вр╕нр╕Зр╣Бр╕Цр╕б! === ЁЯУж");
    let home = IpAddr::V4(127, 0, 0, 1);           // р╕Чр╕╡р╣Ир╕нр╕вр╕╣р╣Ир╕Ър╣Йр╕▓р╕Щр╕лр╕зр╕▓р╕Щ! ЁЯПа
    let loopback = IpAddr::V6(String::from("::1")); // р╕Чр╕▓р╕Зр╕ер╕▒р╕Фр╕Бр╕ер╕▒р╕Ър╕Ър╣Йр╕▓р╕Щ! ЁЯФД

    println!("ЁЯПа р╕Чр╕╡р╣Ир╕нр╕вр╕╣р╣Ир╕Ър╣Йр╕▓р╕Щ: {home:?} (р╕Ър╣Йр╕▓р╕Щр╕лр╕зр╕▓р╕Щр╕Ър╣Йр╕▓р╕Щ! ЁЯТХ)");
    println!("ЁЯФД Loopback: {loopback:?} (р╕Чр╕▓р╕Зр╕ер╕▒р╕Фр╕бр╕лр╕▒р╕ир╕Ир╕гр╕гр╕вр╣М! тЬи)");
    
    // р╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ enum р╕Ьр╣Ир╕▓р╕Щр╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щ (р╣Ар╕гр╕╡р╕вр╕Бр╕Юр╕Щр╕▒р╕Бр╕Зр╕▓р╕Щр╣Ар╕кр╕┤р╕гр╣Мр╕Я! ЁЯФФ)
    display_ip_info(&home);     // р╣Ар╕кр╕┤р╕гр╣Мр╕Яр╕Чр╕╡р╣Ир╕нр╕вр╕╣р╣Ир╕Ър╣Йр╕▓р╕Щ! ЁЯПа
    display_ip_info(&loopback); // р╣Ар╕кр╕┤р╕гр╣Мр╕Яр╕Чр╕▓р╕Зр╕ер╕▒р╕Ф! ЁЯЫдя╕П

    // Complex enum (р╣Ар╕бр╕Щр╕╣р╕Др╕гр╕Ър╕Др╕гр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Щр╕▒р╕Бр╕Ьр╕Ир╕Нр╕ар╕▒р╕в! ЁЯЧ║я╕П)
    #[derive(Debug)]
    enum Message {
        Quit,                        // р╕Ыр╕╕р╣Ир╕бр╕лр╕Щр╕╡р╕Йр╕╕р╕Бр╣Ар╕Йр╕┤р╕Щ! ЁЯЪи
        Move { x: i32, y: i32 },     // р╕Др╕│р╕кр╕▒р╣Ир╕Зр╣Ар╕Чр╣Ар╕ер╕Юр╕нр╕гр╣Мр╕Х! тЪб
        Write(String),               // р╕Ыр╕▓р╕Бр╕Бр╕▓р╕зр╕┤р╣Ар╕ир╕й! тЬТя╕П
        ChangeColor(i32, i32, i32),  // р╕Юр╕╣р╣Ир╕Бр╕▒р╕Щр╕кр╕╡р╕гр╕╕р╣Йр╕З! ЁЯМИ
    }

    impl Message {
        fn call(&self) {  // р╕Хр╕▒р╕зр╣Бр╕Ыр╕ер╕ар╕▓р╕йр╕▓р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б! ЁЯЧгя╕П
            match self {
                Self::Quit => println!("ЁЯЪк р╕нр╕нр╕Бр╕Ир╕▓р╕Бр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕б (р╕Ър╕▓р╕вр╕Ър╕▓р╕в! ЁЯСЛ)"),
                Self::Move { x, y } => println!("ЁЯУН р╣Ар╕Др╕ер╕╖р╣Ир╕нр╕Щр╕Чр╕╡р╣Ир╣Др╕Ы ({x}, {y}) (р╕зр╕╣р╕К! р╣Ар╕Чр╣Ар╕ер╕Юр╕нр╕гр╣Мр╕Х! тЪб)"),
                Self::Write(text) => println!("тЬНя╕П р╣Ар╕Вр╕╡р╕вр╕Щ: {text} (р╕Ыр╕▓р╕Бр╕Бр╕▓р╕зр╕┤р╣Ар╕ир╕йр╕Чр╕│р╕Зр╕▓р╕Щ! тЬи)"),
                Self::ChangeColor(r, g, b) => println!("ЁЯОи р╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щр╕кр╕╡р╣Ар╕Ыр╣Зр╕Щ RGB({r}, {g}, {b}) (р╕Юр╕╣р╣Ир╕Бр╕▒р╕Щр╕кр╕╡р╕гр╕╕р╣Йр╕Зр╣Ар╕гр╕┤р╣Ир╕бр╕Чр╕│р╕Зр╕▓р╕Щ! ЁЯМИ)"),
            }
        }
    }

    println!("\nЁЯУи === Complex Enums: р╕ир╕╣р╕Щр╕вр╣Мр╕гр╕▒р╕Ър╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б! === ЁЯУи");
    let messages = vec![
        Message::Write(String::from("р╕кр╕зр╕▒р╕кр╕Фр╕╡")),  // р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕гр╕▒р╕Б! ЁЯТМ
        Message::Move { x: 10, y: 20 },          // р╕Хр╕▒р╣Лр╕зр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕Ър╕┤р╕Щ! тЬИя╕П
        Message::ChangeColor(255, 0, 0),         // р╕Др╕│р╕кр╕▒р╣Ир╕Зр╣Бр╕Хр╣Ир╕Зр╕лр╕Щр╣Йр╕▓! ЁЯТД
        Message::Quit,                           // р╕Ир╕Фр╕лр╕бр╕▓р╕вр╕ер╕▓р╕нр╕нр╕Б! ЁЯУД
    ];

    for message in messages {  // р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Чр╕╡р╕ер╕░р╕Йр╕Ър╕▒р╕Ъ! ЁЯУо
        message.call();
    }

    // Option enum (р╕Бр╕ер╣Ир╕нр╕Зр╕ер╕╕р╣Йр╕Щр╣Вр╕Кр╕Др╣Бр╕лр╣Ир╕Зр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕б! ЁЯО░)
    println!("\nЁЯОБ === Option Enum: р╕Бр╕ер╣Ир╕нр╕Зр╕ер╕╕р╣Йр╕Щр╣Вр╕Кр╕Д! === ЁЯОБ");
    let some_number = Some(5);                    // р╕Цр╕╣р╕Бр╕гр╕▓р╕Зр╕зр╕▒р╕ер╕Хр╕▒р╕зр╣Ар╕ер╕В! ЁЯОК
    let some_string = Some("a string");           // р╕Цр╕╣р╕Бр╕гр╕▓р╕Зр╕зр╕▒р╕ер╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б! ЁЯУЬ
    let absent_number: Option<i32> = None;        // р╣Др╕бр╣Ир╕Цр╕╣р╕Бр╕гр╕▓р╕Зр╕зр╕▒р╕е! ЁЯШв

    println!("тЬЕ р╕бр╕╡р╕Хр╕▒р╕зр╣Ар╕ер╕В: {some_number:?} (р╣Вр╕Кр╕Др╕Фр╕╡! ЁЯНА)");
    println!("тЬЕ р╕бр╕╡р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б: {some_string:?} (р╣Бр╕Ир╣Зр╕Др╕Юр╕нр╕Х! ЁЯТ░)");
    println!("тЭМ р╣Др╕бр╣Ир╕бр╕╡р╕Хр╕▒р╕зр╣Ар╕ер╕В: {absent_number:?} (р╣Ар╕кр╕╡р╕вр╣Гр╕Ир╕Фр╣Йр╕зр╕в! ЁЯТФ)");

    // Pattern matching with Option (р╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕Др╕┤р╕Фр╣Ар╕ер╕Вр╕зр╕┤р╣Ар╕ир╕й! ЁЯзЩтАНтЩВя╕П)
    fn plus_one(x: Option<i32>) -> Option<i32> {
        x.map(|i| i + 1)  // р╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣Мр╕Ър╕зр╕Бр╕лр╕Щр╕╢р╣Ир╕З! тЬи
    }

    let five = Some(5);              // р╣Ар╕ер╕В 5 р╣Гр╕Щр╕Бр╕ер╣Ир╕нр╕З! ЁЯУж
    let six = plus_one(five);        // р╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣Мр╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щ 5 р╣Ар╕Ыр╣Зр╕Щ 6! ЁЯОй
    let none = plus_one(None);       // р╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣Мр╕Бр╕▒р╕Ър╕Бр╕ер╣Ир╕нр╕Зр╕зр╣Ир╕▓р╕З! ЁЯкД

    println!("ЁЯФв 5 + 1 = {six:?} (р╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣Мр╕кр╕│р╣Ар╕гр╣Зр╕И! тЬи)");
    println!("тЭМ None + 1 = {none:?} (р╣Ар╕зр╕Чр╕бр╕Щр╕Хр╕гр╣Мр╣Др╕бр╣Ир╣Др╕Фр╣Йр╕Ьр╕е! ЁЯЪл)");

    // Result enum (р╕ир╕▓р╕ер╕вр╕╕р╕Хр╕┤р╕Шр╕гр╕гр╕бр╣Бр╕лр╣Ир╕Зр╕Бр╕▓р╕гр╕Др╕│р╕Щр╕зр╕У! тЪЦя╕П)
    println!("\nтЬЕ === Result Enum: р╕ир╕▓р╕ер╕вр╕╕р╕Хр╕┤р╕Шр╕гр╕гр╕б! === тЬЕ");
    fn divide(a: f64, b: f64) -> Result<f64, String> {  // р╕Ьр╕╣р╣Йр╕Юр╕┤р╕Юр╕▓р╕Бр╕йр╕▓р╕Др╕Ур╕┤р╕Хр╕ир╕▓р╕кр╕Хр╕гр╣М! ЁЯСитАНтЪЦя╕П
        if b == 0.0 {
            Err(String::from("р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕лр╕▓р╕гр╕Фр╣Йр╕зр╕вр╕ир╕╣р╕Щр╕вр╣Мр╣Др╕Фр╣Й"))  // р╕Др╕│р╕Юр╕┤р╕Юр╕▓р╕Бр╕йр╕▓: р╕Ьр╕┤р╕Фр╕Бр╕Ор╕лр╕бр╕▓р╕в! ЁЯЪл
        } else {
            Ok(a / b)  // р╕Др╕│р╕Юр╕┤р╕Юр╕▓р╕Бр╕йр╕▓: р╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З! тЬЕ
        }
    }

    let result1 = divide(10.0, 2.0);  // р╕Др╕Фр╕╡р╕Чр╕╡р╣И 1: р╕Бр╕▓р╕гр╕лр╕▓р╕гр╕Ыр╕Бр╕Хр╕┤! ЁЯУЛ
    let result2 = divide(10.0, 0.0);  // р╕Др╕Фр╕╡р╕Чр╕╡р╣И 2: р╕Бр╕▓р╕гр╕лр╕▓р╕гр╕Хр╣Йр╕нр╕Зр╕лр╣Йр╕▓р╕б! тЪая╕П

    match result1 {  // р╕нр╣Ир╕▓р╕Щр╕Др╕│р╕Юр╕┤р╕Юр╕▓р╕Бр╕йр╕▓р╕Др╕Фр╕╡р╕Чр╕╡р╣И 1! ЁЯУЬ
        Ok(value) => println!("тЬЕ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М: {value} (р╕Кр╕Щр╕░р╕Др╕Фр╕╡! ЁЯПЖ)"),
        Err(error) => println!("тЭМ р╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Ф: {error} (р╣Бр╕Юр╣Йр╕Др╕Фр╕╡! ЁЯТ╕)"),
    }

    match result2 {  // р╕нр╣Ир╕▓р╕Щр╕Др╕│р╕Юр╕┤р╕Юр╕▓р╕Бр╕йр╕▓р╕Др╕Фр╕╡р╕Чр╕╡р╣И 2! ЁЯУЬ
        Ok(value) => println!("тЬЕ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М: {value} (р╕Кр╕Щр╕░р╕Др╕Фр╕╡! ЁЯПЖ)"),
        Err(error) => println!("тЭМ р╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Ф: {error} (р╣Бр╕Юр╣Йр╕Др╕Фр╕╡! ЁЯТ╕)"),
    }

    // Advanced pattern matching (р╕Щр╕▒р╕Бр╕кр╕╖р╕Ър╣Ар╕Йр╕Юр╕▓р╕░р╕Чр╕▓р╕З! ЁЯХ╡я╕ПтАНтЩВя╕П)
    println!("\nЁЯОп === Advanced Pattern Matching: р╕кр╕│р╕Щр╕▒р╕Бр╕Зр╕▓р╕Щр╕кр╕╖р╕Ър╕кр╕зр╕Щ! === ЁЯОп");
    let config_max = Some(3u8);  // р╕лр╕ер╕▒р╕Бр╕Рр╕▓р╕Щр╕Кр╕┤р╣Йр╕Щр╕Чр╕╡р╣И 1! ЁЯФН

    if let Some(max) = config_max {  // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕лр╕ер╕▒р╕Бр╕Рр╕▓р╕Щ! ЁЯФО
        println!("ЁЯФз р╕Др╣Ир╕▓р╕кр╕╣р╕Зр╕кр╕╕р╕Фр╕Чр╕╡р╣Ир╕Бр╕│р╕лр╕Щр╕Фр╣Др╕зр╣Й: {max} (р╕Юр╕Ър╕лр╕ер╕▒р╕Бр╕Рр╕▓р╕Щ! ЁЯУЛ)");
    }

    let mut count = 0;        // р╕Хр╕╣р╣Йр╣Ар╕Лр╕Яр╕кр╣Ир╕зр╕Щр╕Хр╕▒р╕з! ЁЯПж
    let coin = Some(25);      // р╣Ар╕лр╕гр╕╡р╕вр╕Нр╕ер╕╢р╕Бр╕ер╕▒р╕Ъ! ЁЯкЩ

    if let Some(value) = coin {  // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Ар╕лр╕гр╕╡р╕вр╕Н! ЁЯФН
        count += value;
        println!("ЁЯТ░ р╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕лр╕гр╕╡р╕вр╕Н {value} р╣Ар╕лр╕гр╕╡р╕вр╕Н, р╕гр╕зр╕б: {count} (р╕гр╕зр╕вр╕Вр╕╢р╣Йр╕Щр╣Бр╕ер╣Йр╕з! ЁЯТ╕)");
    } else {
        println!("ЁЯЪл р╣Др╕бр╣Ир╕бр╕╡р╣Ар╕лр╕гр╕╡р╕вр╕Н (р╕вр╕▓р╕Бр╕Ир╕Щр╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Фр╕┤р╕б! ЁЯШв)");
    }
}
