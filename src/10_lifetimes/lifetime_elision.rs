/// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏≠‡∏ô‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á Lifetime Elision Rules - ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏™‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢! üé©‚ú®
/// ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ lifetime ‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥! ü™Ñ
pub fn learn_lifetime_elision() {
    println!("\nüéØ === Lifetime Elision Rules: ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢! === üéØ");

    println!("üìã ‡∏Å‡∏é‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå‡∏Å‡∏≤‡∏£ Elision (‡∏Å‡∏é‡∏Ç‡∏≠‡∏á‡∏ô‡∏±‡∏Å‡πÄ‡∏ß‡∏ó‡∏¢‡πå‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢!):");
    println!("1Ô∏è‚É£ ‡πÅ‡∏ï‡πà‡∏•‡∏∞ reference parameter ‡πÑ‡∏î‡πâ lifetime parameter ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡πÑ‡∏î‡πâ‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á!)");
    println!("2Ô∏è‚É£ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ input lifetime parameter ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö output ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏£‡∏π‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≠‡∏ô‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡πâ‡∏≠‡∏á!)");
    println!("3Ô∏è‚É£ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ &self ‡∏´‡∏£‡∏∑‡∏≠ &mut self ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ lifetime ‡∏Ç‡∏≠‡∏á self ‡∏Å‡∏±‡∏ö output (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢‡πÉ‡∏ä‡πâ‡∏≠‡∏≥‡∏ô‡∏≤‡∏à‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏•‡∏π‡∏Å‡∏ô‡πâ‡∏≠‡∏á!)");

    // Rule 1: ‡πÅ‡∏ï‡πà‡∏•‡∏∞ parameter ‡πÑ‡∏î‡πâ lifetime ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á - ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏à‡∏Å‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô! üÜî
    const fn rule1_example(s: &str) -> usize {
        // ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏≠: fn rule1_example<'a>(s: &'a str) -> usize
        // Rust ‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏±‡∏Å‡πÄ‡∏ß‡∏ó‡∏¢‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° <'a> ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥! ‚ú®
        s.len()
    }

    println!("\n1Ô∏è‚É£ === ‡∏Å‡∏é‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡∏Å‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢! === 1Ô∏è‚É£");
    let text = "Hello Rust";
    println!("üìè ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á '{}': {}", text, rule1_example(text));

    // Rule 2: input lifetime ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß -> ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö output - ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏£‡∏π‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≠‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡πâ‡∏≠‡∏á! üë®‚Äçüè´
    fn rule2_example(s: &str) -> &str {
        // ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏≠: fn rule2_example<'a>(s: &'a str) -> &'a str
        // Rust ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ output ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö input! üß†
        &s[0..1]
    }

    println!("\n2Ô∏è‚É£ === ‡∏Å‡∏é‡∏ó‡∏µ‡πà 2: ‡∏Ñ‡∏£‡∏π‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≠‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡πâ‡∏≠‡∏á! === 2Ô∏è‚É£");
    let first_char = rule2_example(text);
    println!("üî§ ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á '{text}': '{first_char}'");

    // Rule 3: ‡∏°‡∏µ &self -> ‡πÉ‡∏ä‡πâ lifetime ‡∏Ç‡∏≠‡∏á self - ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢‡πÉ‡∏ä‡πâ‡∏≠‡∏≥‡∏ô‡∏≤‡∏à! üëë
    struct TextProcessor {
        prefix: String,  // ‡∏Ñ‡∏≥‡∏ô‡∏≥‡∏´‡∏ô‡πâ‡∏≤ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏¢‡∏®‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢!)
    }

    impl TextProcessor {
        fn new(prefix: &str) -> Self {
            Self {
                prefix: prefix.to_string(),
            }
        }

        // ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏≠: fn process<'a>(&'a self, input: &str) -> &'a str
        // ‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢ (self) ‡πÉ‡∏ä‡πâ‡∏≠‡∏≥‡∏ô‡∏≤‡∏à‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏Å‡∏±‡∏ö output! üëë
        fn process(&self, _input: &str) -> &str {
            &self.prefix
        }

        // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏ß‡πà‡∏≤
        fn combine(&self, suffix: &str) -> String {
            format!("{}-{}", self.prefix, suffix)
        }
    }

    println!("\n3Ô∏è‚É£ === ‡∏Å‡∏é‡∏ó‡∏µ‡πà 3: ‡∏≠‡∏≥‡∏ô‡∏≤‡∏à‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢! === 3Ô∏è‚É£");
    let processor = TextProcessor::new("RUST");
    let processed = processor.process("input");
    println!("‚öôÔ∏è ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: {processed}");

    let combined = processor.combine("LANG");
    println!("üîó ‡∏£‡∏ß‡∏°: {combined}");

    // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ lifetime ‡πÄ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ elide ‡πÑ‡∏î‡πâ) - ‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! üí•
    fn cannot_elide<'a>(x: &'a str, y: &str) -> &'a str {
        // ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ elide ‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ 2 input lifetimes ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ &self
        // Rust ‡∏™‡∏±‡∏ö‡∏™‡∏ô: "‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å lifetime ‡πÑ‡∏´‡∏ô‡∏î‡∏µ?" ü§î
        println!("üîç ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö: {x} vs {y}");
        x
    }

    println!("\n‚ùå === ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ Elide ‡πÑ‡∏î‡πâ: ‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! === ‚ùå");
    let str1 = "First";
    let str2 = "Second";
    let result = cannot_elide(str1, str2);
    println!("üì§ ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: {result}");

    // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ lifetime bounds - ‡∏Å‡∏é‡πÄ‡∏´‡∏•‡πá‡∏Å‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢! ‚õìÔ∏è
    fn lifetime_bound_example<'a, T>(x: &'a T) -> &'a T
    where
        T: std::fmt::Display + 'a,  // T ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≤‡∏ô‡∏û‡∏≠ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏à‡πâ‡∏≤‡∏á‡∏á‡∏≤‡∏ô!)
    {
        println!("üìÑ ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤: {x}");
        x
    }

    println!("\nüîí === Lifetime Bounds: ‡∏Å‡∏é‡πÄ‡∏´‡∏•‡πá‡∏Å‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏±‡∏¢! === üîí");
    let number = 42;
    let bounded_result = lifetime_bound_example(&number);
    println!("üî¢ ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ bound: {bounded_result}");
}
