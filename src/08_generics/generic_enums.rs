//! Generic Enums - ‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡∏á‡∏ô‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥! üéØ‚ú®
//!
//! ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏•‡∏∂‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á!
//! Enum ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó - ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏≠‡∏á Generics! üé≤üé™
//! ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ï‡∏π‡πâ‡πÄ‡∏™‡∏∑‡πâ‡∏≠‡∏ú‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏™‡πà‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡πÑ‡∏ã‡∏™‡πå ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡πâ‡∏≤‡∏ô‡∏Ç‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á! üëïüè™

/// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏≠‡∏ô‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á Generic Enums
/// ‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Enum ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Å‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏±‡∏ô‡πÄ‡∏ñ‡∏≠‡∏∞! ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏•‡∏∂‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ! üéØ
/// 
/// ‡πÉ‡∏ä‡πâ #[`allow(clippy::too_many_lines)`] ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ
/// ‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡∏Ç‡∏≠‡∏á Generic Enums ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á
#[allow(clippy::too_many_lines)]
pub fn learn_generic_enums() {
    println!("üéØ === Generic Enums ‡πÉ‡∏ô Rust: Enum ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥! === üéØ");
    println!("üé™ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏ä‡∏ß‡πå‡∏ß‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏ô‡∏±‡∏Å‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ö‡∏ó! üé≠‚ú®");

    println!("\nüì¶ === Option<T>: ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ! === üì¶");
    println!("üéÅ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ç‡∏ß‡∏±‡∏ç‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£ ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà! üéüÔ∏èü§û");

    // Option<T> - built-in generic enum (Enum ‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏° Rust!)
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;

    println!("üî¢ Some number: {some_number:?} (‡∏°‡∏µ‡πÄ‡∏•‡∏Ç 5 ‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô!)");
    println!("üìù Some string: {some_string:?} (‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡πà‡∏≠‡∏ô‡∏≠‡∏¢‡∏π‡πà!)");
    println!("‚ùå Absent number: {absent_number:?} (‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£!)");

    // Pattern matching with Option - ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô!
    match some_number {
        Some(value) => println!("‚úÖ Found value: {value} (‡πÄ‡∏à‡∏≠‡∏Ç‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß!)"),
        None => println!("‚ùå No value found (‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤!)"),
    }

    println!("\n‚ö° === Result<T, E>: ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! === ‚ö°");
    println!("üéØ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏ä‡∏ô‡∏∞‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏û‡πâ! üìùüéÆ");

    // Result<T, E> - built-in generic enum (Enum ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î!)
    let good_result: Result<i32, &str> = Ok(10);
    let bad_result: Result<i32, &str> = Err("Something went wrong");

    println!("‚úÖ Good result: {good_result:?} (‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!)");
    println!("‚ùå Bad result: {bad_result:?} (‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô!)");

    // Pattern matching with Result - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß!
    match good_result {
        Ok(value) => println!("‚úÖ Success: {value} (‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£!)"),
        Err(error) => println!("‚ùå Error: {error} (‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î!)"),
    }

    match bad_result {
        Ok(value) => println!("‚úÖ Success: {value} (‡πÑ‡∏°‡πà‡∏ô‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏≤‡∏ñ‡∏∂‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ!)"),
        Err(error) => println!("‚ùå Error: {error} (‡∏Ñ‡∏≤‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î!)"),
    }

    println!("\nüîÄ === Custom Generic Enum: Either - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤! === üîÄ");
    println!("üõ§Ô∏è ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏¢‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 2 ‡∏≠‡∏¢‡πà‡∏≤‡∏á! üçïüçî");

    // Custom generic enum - Enum ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏≠‡∏á!
    #[derive(Debug)]
    enum Either<L, R> {
        Left(L),   // ‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢
        Right(R),  // ‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤
    }

    impl<L, R> Either<L, R> {
        const fn is_left(&self) -> bool {
            matches!(self, Self::Left(_))
        }

        const fn is_right(&self) -> bool {
            matches!(self, Self::Right(_))
        }

        fn left(self) -> Option<L> {
            match self {
                Self::Left(value) => Some(value),
                Self::Right(_) => None,
            }
        }

        fn right(self) -> Option<R> {
            match self {
                Self::Left(_) => None,
                Self::Right(value) => Some(value),
            }
        }
    }

    let left_value: Either<i32, String> = Either::Left(42);
    let right_value: Either<i32, String> = Either::Right(String::from("Hello"));

    println!("‚¨ÖÔ∏è Left value: {left_value:?} (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢ ‡πÑ‡∏î‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç!)");
    println!("‚û°Ô∏è Right value: {right_value:?} (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤ ‡πÑ‡∏î‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°!)");

    println!("‚¨ÖÔ∏è Is left? {} (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏´‡∏°?)", left_value.is_left());
    println!("‚û°Ô∏è Is right? {} (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡πÑ‡∏´‡∏°?)", right_value.is_right());

    // Extract values - ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πà‡∏≠‡∏á!
    if let Some(value) = left_value.left() {
        println!("‚¨ÖÔ∏è Extracted left value: {value} (‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏î‡πâ!)");
    }

    if let Some(value) = right_value.right() {
        println!("‚û°Ô∏è Extracted right value: {value} (‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡πÑ‡∏î‡πâ!)");
    }

    println!("\nüå≥ === Generic Binary Tree: ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏™‡∏≤‡∏Ç‡∏≤‡πÑ‡∏î‡πâ! === üå≥");
    println!("üåø ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏ú‡πà‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏´‡∏ô‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏≤‡∏¢‡πÄ‡∏•‡∏∑‡∏≠‡∏î! üéãüë®‚Äçüë©‚Äçüëß‚Äçüë¶");

    // More complex generic enum - Binary Tree (‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô!)
    #[derive(Debug, Clone)]
    enum BinaryTree<T> {
        Empty,  // ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤
        Node {
            value: T,                        // ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î
            left: Box<BinaryTree<T>>,       // ‡∏Å‡∏¥‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢
            right: Box<BinaryTree<T>>,      // ‡∏Å‡∏¥‡πà‡∏á‡∏Ç‡∏ß‡∏≤
        },
    }

    impl<T> BinaryTree<T> {
        const fn new() -> Self {
            Self::Empty
        }

        fn leaf(value: T) -> Self {
            Self::Node {
                value,
                left: Box::new(Self::Empty),
                right: Box::new(Self::Empty),
            }
        }

        fn node(value: T, left: Self, right: Self) -> Self {
            Self::Node {
                value,
                left: Box::new(left),
                right: Box::new(right),
            }
        }

        const fn is_empty(&self) -> bool {
            matches!(self, Self::Empty)
        }
    }

    impl<T: std::fmt::Display> BinaryTree<T> {
        fn print_inorder(&self) {
            // ‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏ö‡∏ö in-order (‡∏ã‡πâ‡∏≤‡∏¢-‡∏Å‡∏•‡∏≤‡∏á-‡∏Ç‡∏ß‡∏≤)
            match self {
                Self::Empty => {}, // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏û‡∏¥‡∏°‡∏û‡πå
                Self::Node { value, left, right } => {
                    left.print_inorder();   // ‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Å‡∏¥‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Å‡πà‡∏≠‡∏ô
                    print!("{value} ");      // ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡πà‡∏≤‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
                    right.print_inorder();  // ‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Å‡∏¥‡πà‡∏á‡∏Ç‡∏ß‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
                }
            }
        }
    }

    // Create a binary tree - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á!
    let tree = BinaryTree::node(
        1,  // ‡∏£‡∏≤‡∏Å‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        BinaryTree::node(2, BinaryTree::leaf(4), BinaryTree::leaf(5)), // ‡∏Å‡∏¥‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢
        BinaryTree::node(3, BinaryTree::leaf(6), BinaryTree::leaf(7)), // ‡∏Å‡∏¥‡πà‡∏á‡∏Ç‡∏ß‡∏≤
    );

    println!("üå≥ Binary Tree: {tree:?} (‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°!)");
    print!("üîÑ In-order traversal: (‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö!) ");
    tree.print_inorder();
    println!();

    let empty_tree: BinaryTree<i32> = BinaryTree::new();
    println!("üå≥ Empty tree is empty: {} (‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤‡∏à‡∏£‡∏¥‡∏á‡πÜ!)", empty_tree.is_empty());
    println!("üå≥ Main tree is empty: {} (‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏´‡∏•‡∏±‡∏Å‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤!)", tree.is_empty());
}
