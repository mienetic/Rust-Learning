//! Generic Structs - р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕╡р╣Ир╣Др╕бр╣Ир╣Ар╕ер╕╖р╕нр╕Бр╕Ыр╕Пр╕┤р╕Ър╕▒р╕Хр╕┤! ЁЯПЧя╕ПтЬи
//!
//! р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕ер╣Ир╕нр╕Зр╕зр╕┤р╣Ар╕ир╕йр╕Чр╕╡р╣Ир╣Гр╕кр╣Ир╕нр╕░р╣Др╕гр╕Бр╣Зр╣Др╕Фр╣Й р╕лр╕гр╕╖р╕нр╕Ър╣Йр╕▓р╕Щр╕Чр╕╡р╣Ир╕нр╕вр╕╣р╣Ир╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕кр╕▓р╕вр╕Юр╕▒р╕Щр╕Шр╕╕р╣М!
//! Struct р╣Ар╕Фр╕╡р╕вр╕з р╕гр╕нр╕Зр╕гр╕▒р╕Ър╣Др╕Фр╣Йр╕лр╕ер╕▓р╕вр╕Ыр╕гр╕░р╣Ар╕ар╕Ч - р╕Щр╕╡р╣Ир╕Др╕╖р╕нр╕Др╕зр╕▓р╕бр╕вр╕╖р╕Фр╕лр╕вр╕╕р╣Ир╕Щр╕Вр╕нр╕З Generics! ЁЯУжЁЯОн
//! р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Вр╕гр╕Зр╣Бр╕гр╕б 5 р╕Фр╕▓р╕зр╕Чр╕╡р╣Ир╕гр╕▒р╕Ър╣Бр╕Вр╕Бр╕Чр╕╕р╕Бр╣Ар╕Кр╕╖р╣Йр╕нр╕Кр╕▓р╕Хр╕┤ р╕лр╕гр╕╖р╕нр╕гр╣Йр╕▓р╕Щр╕нр╕▓р╕лр╕▓р╕гр╕Чр╕╡р╣Ир╕Чр╕│р╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╣Ар╕бр╕Щр╕╣! ЁЯПиЁЯН╜я╕П

/// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕кр╕нр╕Щр╣Ар╕гр╕╖р╣Ир╕нр╕З Generic Structs
/// р╕бр╕▓р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕З Struct р╕Чр╕╡р╣Ир╕Чр╕│р╕Зр╕▓р╕Щр╕Бр╕▒р╕Ър╕лр╕ер╕▓р╕вр╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Бр╕▒р╕Щр╣Ар╕Цр╕нр╕░!
pub fn learn_generic_structs() {
    println!("ЁЯПЧя╕П === Generic Structs р╣Гр╕Щ Rust: р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╣Ар╕ер╕╖р╕нр╕Бр╕Ыр╕Пр╕┤р╕Ър╕▒р╕Хр╕┤! === ЁЯПЧя╕П");
    println!("ЁЯОк р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Хр╣Зр╕Щр╕Чр╣Мр╕вр╕▒р╕Бр╕йр╣Мр╕Чр╕╡р╣Ир╕гр╕нр╕Зр╕гр╕▒р╕Ър╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕Бр╕▓р╕гр╣Бр╕кр╕Фр╕З р╕лр╕гр╕╖р╕нр╕кр╕Щр╕▓р╕бр╕Бр╕╡р╕мр╕▓р╕Чр╕╡р╣Ир╣Ар╕ер╣Ир╕Щр╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕Бр╕╡р╕мр╕▓! тЪ╜ЁЯПАЁЯО╛");

    // Point struct with single type parameter - р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╕гр╕▒р╕Ър╕Чр╕╕р╕Бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч!
    // р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Ир╕╕р╕Фр╕Щр╕▒р╕Фр╕Юр╕Ър╕Чр╕╡р╣Ир╕Чр╕╕р╕Бр╕Др╕Щр╕бр╕▓р╣Др╕Фр╣Й р╕лр╕гр╕╖р╕нр╕кр╕Цр╕▓р╕Щр╕╡р╕гр╕Цр╣Др╕Яр╕Чр╕╡р╣Ир╕гр╕Цр╕Чр╕╕р╕Бр╕Вр╕Ър╕зр╕Щр╣Бр╕зр╕░! ЁЯЪВЁЯЪЙ
    #[derive(Debug, Clone)]
    struct Point<T> {
        x: T,
        y: T,
    }

    impl<T> Point<T> {
        const fn new(x: T, y: T) -> Self {
            Self { x, y }
        }

        const fn x(&self) -> &T {
            &self.x
        }

        const fn y(&self) -> &T {
            &self.y
        }
    }

    // Methods for specific types - р╣Ар╕бр╕Шр╕нр╕Фр╕Юр╕┤р╣Ар╕ир╕йр╕кр╕│р╕лр╕гр╕▒р╕Ъ f32 р╣Ар╕Чр╣Ир╕▓р╕Щр╕▒р╣Йр╕Щ!
    // р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Ър╕гр╕┤р╕Бр╕▓р╕гр╕Юр╕┤р╣Ар╕ир╕йр╕кр╕│р╕лр╕гр╕▒р╕Ър╕кр╕бр╕▓р╕Кр╕┤р╕Б VIP р╕лр╕гр╕╖р╕нр╣Ар╕бр╕Щр╕╣р╕ер╕▒р╕Ър╕Чр╕╡р╣Ир╕бр╕╡р╣Бр╕Др╣Ир╕Ър╕▓р╕Зр╕Др╕Щ! ЁЯТОЁЯОл
    impl Point<f32> {
        fn distance_from_origin(&self) -> f32 {
            self.x.hypot(self.y)
        }
    }

    println!("\nЁЯУН === Point Struct: р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕Ир╕│р╕Бр╕▒р╕Фр╕бр╕┤р╕Хр╕┤! === ЁЯУН");
    println!("ЁЯМЯ р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Фр╕▓р╕зр╕Чр╕╡р╣Ир╕кр╣Ир╕нр╕Зр╣Бр╕кр╕Зр╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕кр╕╡ р╕лр╕гр╕╖р╕нр╣Ар╕Вр╣Зр╕бр╕Чр╕┤р╕ир╕Чр╕╡р╣Ир╕Кр╕╡р╣Йр╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕Чр╕┤р╕и! тнРЁЯзн");

    let integer_point = Point::new(5, 10);
    let float_point = Point::new(1.0, 4.0);

    println!("ЁЯФв Integer Point: {integer_point:?} (р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╕Кр╕нр╕Ър╣Ар╕ер╕Вр╣Ар╕Хр╣Зр╕б!)");
    println!("ЁЯФв x: {}, y: {} (р╕Юр╕┤р╕Бр╕▒р╕Фр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕╡р╕Чр╕ир╕Щр╕┤р╕вр╕б!)", integer_point.x(), integer_point.y());

    println!("ЁЯФв Float Point: {float_point:?} (р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╕Кр╕нр╕Ър╕Чр╕ир╕Щр╕┤р╕вр╕б!)");
    println!(
        "ЁЯУП Distance from origin: {:.2} (р╕гр╕░р╕вр╕░р╕Чр╕▓р╕Зр╕Ир╕▓р╕Бр╕Ир╕╕р╕Фр╕Бр╕│р╣Ар╕Щр╕┤р╕Ф - р╣Гр╕Кр╣Йр╕Чр╕др╕йр╕Ор╕╡р╕Юр╕╡р╕Чр╕▓р╣Вр╕Бр╕гр╕▒р╕к!)",
        float_point.distance_from_origin()
    );

    // Point with multiple type parameters - р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╕Кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕лр╕ер╕▓р╕Бр╕лр╕ер╕▓р╕в!
    // р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Зр╕▓р╕Щр╣Бр╕Хр╣Ир╕Зр╕Зр╕▓р╕Щр╕Вр╣Йр╕▓р╕бр╕зр╕▒р╕Тр╕Щр╕Шр╕гр╕гр╕б р╕лр╕гр╕╖р╕нр╕гр╣Йр╕▓р╕Щр╕нр╕▓р╕лр╕▓р╕гр╕Яр╕┤р╕зр╕Кр╕▒р╣Ир╕Щр╕Чр╕╡р╣Ир╕Ьр╕кр╕бр╕Чр╕╕р╕Бр╕нр╕вр╣Ир╕▓р╕З! ЁЯТТЁЯНЬ
    #[derive(Debug)]
    struct MixedPoint<T, U> {
        x: T,
        y: U,
    }

    impl<T, U> MixedPoint<T, U> {
        const fn new(x: T, y: U) -> Self {
            Self { x, y }
        }

        fn mixup<V, W>(self, other: MixedPoint<V, W>) -> MixedPoint<T, W> {
            // р╣Ар╕нр╕▓ x р╕Ир╕▓р╕Бр╕Хр╕▒р╕зр╣Ар╕нр╕З y р╕Ир╕▓р╕Бр╕Др╕Щр╕нр╕╖р╣Ир╕Щ - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕▓р╕гр╕Ьр╕кр╕бр╕Юр╕▒р╕Щр╕Шр╕╕р╣М!
            MixedPoint {
                x: self.x,
                y: other.y,
            }
        }
    }

    println!("\nЁЯОн === Mixed Point: р╕Ир╕╕р╕Фр╕Чр╕╡р╣Ир╕Кр╕нр╕Ър╕Др╕зр╕▓р╕бр╣Бр╕Ыр╕ер╕Бр╣Гр╕лр╕бр╣И! === ЁЯОн");

    let p1 = MixedPoint::new(5, 10.4);
    let p2 = MixedPoint::new("Hello", 'c');

    println!("ЁЯУН Point 1: {p1:?} (р╕Хр╕▒р╕зр╣Ар╕ер╕Вр╕Бр╕▒р╕Ър╕Чр╕ир╕Щр╕┤р╕вр╕б - р╕Др╕╣р╣Ир╕лр╕зр╕▓р╕Щ!)");
    println!("ЁЯУН Point 2: {p2:?} (р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Бр╕▒р╕Ър╕Хр╕▒р╕зр╕нр╕▒р╕Бр╕йр╕г - р╕Др╕╣р╣Ир╣Бр╕Ыр╕ер╕Б!)");

    let p3 = p1.mixup(p2);
    println!("ЁЯОн Mixed Point: {p3:?} (р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Ир╕▓р╕Бр╕Бр╕▓р╕гр╕Ьр╕кр╕бр╕Юр╕▒р╕Щр╕Шр╕╕р╣М!)");

    // Container struct - р╕Бр╕ер╣Ир╕нр╕Зр╕зр╕┤р╣Ар╕ир╕йр╕Чр╕╡р╣Ир╣Гр╕кр╣Ир╕нр╕░р╣Др╕гр╕Бр╣Зр╣Др╕Фр╣Й!
    #[derive(Debug)]
    struct Container<T> {
        items: Vec<T>,
    }

    impl<T> Container<T> {
        const fn new() -> Self {
            Self { items: Vec::new() }
        }

        fn add(&mut self, item: T) {
            self.items.push(item);
        }

        fn get(&self, index: usize) -> Option<&T> {
            self.items.get(index)
        }

        const fn len(&self) -> usize {
            self.items.len()
        }
    }

    impl<T: std::fmt::Display> Container<T> {
        fn display_all(&self) {
            // р╣Бр╕кр╕Фр╕Зр╕Чр╕╕р╕Бр╕нр╕вр╣Ир╕▓р╕Зр╣Гр╕Щр╕Бр╕ер╣Ир╕нр╕З - р╣Ар╕лр╕бр╕╖р╕нр╕Щр╣Ар╕Ыр╕┤р╕Фр╕Бр╕ер╣Ир╕нр╕Зр╕Вр╕нр╕Зр╕Вр╕зр╕▒р╕Н!
            for (i, item) in self.items.iter().enumerate() {
                println!("  [{i}]: {item}");
            }
        }
    }

    println!("\nЁЯУж === Container: р╕Бр╕ер╣Ир╕нр╕Зр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╣Ар╕ер╕╖р╕нр╕Бр╕Вр╕нр╕З! === ЁЯУж");
    println!("ЁЯОБ р╣Ар╕лр╕бр╕╖р╕нр╕Щр╕Бр╕ер╣Ир╕нр╕Зр╣Вр╕Фр╣Ар╕гр╕бр╕нр╕Щр╕Чр╕╡р╣Ир╣Гр╕кр╣Ир╕Вр╕нр╕Зр╕зр╕┤р╣Ар╕ир╕йр╣Др╕Фр╣Йр╕Чр╕╕р╕Бр╕нр╕вр╣Ир╕▓р╕З р╕лр╕гр╕╖р╕нр╕Бр╕гр╕░р╣Ар╕Ыр╣Лр╕▓р╣Бр╕ор╕гр╣Мр╕гр╕╡р╣И р╕Юр╕нр╕Хр╣Ар╕Хр╕нр╕гр╣М! ЁЯкДтЬи");

    let mut number_container = Container::new();
    number_container.add(1);
    number_container.add(2);
    number_container.add(3);

    println!("ЁЯФв Number Container: {number_container:?} (р╕Бр╕ер╣Ир╕нр╕Зр╣Ар╕ер╕Вр╕Чр╕╡р╣Ир╣Ар╕гр╕╡р╕вр╕Зр╕Хр╕▒р╕зр╕Фр╕╡!)");
    println!("ЁЯУК Length: {} (р╕бр╕╡р╕Вр╕нр╕З {} р╕Кр╕┤р╣Йр╕Щ!)", number_container.len(), number_container.len());
    println!("ЁЯФН Item at index 1: {:?} (р╕Вр╕нр╕Зр╕Кр╕┤р╣Йр╕Щр╕Чр╕╡р╣И 2 р╕Др╕╖р╕н...)", number_container.get(1));

    println!("ЁЯУЛ All items: (р╣Ар╕Ыр╕┤р╕Фр╕Бр╕ер╣Ир╕нр╕Зр╕Фр╕╣р╕Вр╕нр╕Зр╕Чр╕╕р╕Бр╕Кр╕┤р╣Йр╕Щ!)");
    number_container.display_all();

    let mut string_container = Container::new();
    string_container.add(String::from("Hello"));
    string_container.add(String::from("World"));

    println!("\nЁЯУЭ String Container: {string_container:?} (р╕Бр╕ер╣Ир╕нр╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Чр╕╡р╣Ир╕Щр╣Ир╕▓р╕гр╕▒р╕Б!)");
    println!("ЁЯУЛ All strings: (р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Фр╣Гр╕Щр╕Бр╕ер╣Ир╕нр╕З!)");
    string_container.display_all();
}
